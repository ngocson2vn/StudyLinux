<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--
 Archive processed by SingleFile 
 url: http://www.ntu.edu.sg/home/ehchua/programming/cpp/cp7_OperatorOverloading.html 
 saved date: Mon Aug 25 2014 15:17:29 GMT+0900 (Tokyo Standard Time) 
--><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Object-oriented Programming (OOP) in C++</title>
<style rel="stylesheet" type="text/css" data-href="http://www.ntu.edu.sg/home/ehchua/programming/css/programming_notes_v1.css">/* 
 * Universal selector - clear all the margin and padding to get consistent layout for Firefox and IE 
 */
* { 
	margin: 0;
	padding: 0;
}

/* 
 * Set default style for all the tags.
 * Apply to the main content division as well.
 */
body {
	background-color: rgb(202, 251, 237);
	color: #000;
	font-family: "Segoe UI", Segoe, Calibri, "Ubuntu", Tahoma, Arial, Helvetica, Verdana, sans-serif;
	font-size: 14px;
	text-align: justify;
	line-height: 1.5;
}

/*
 * "wrap-outer" wraps header, wrap-inner and footer
 */
#wrap-outer {
	margin: 20px 20px 20px 20px;
	padding: 0;
	
}
/*
 * "wrap-inner" wraps content-header, content-main and content-footer
 */
#wrap-inner {
	background-color: #fff;
	margin: 0;
	border: 1px solid #ddd;
	padding: 25px 15px;
	box-shadow: 5px 5px 0 #ddd;
}
#content-header {
	margin: 0;
	padding: 50px 0 10px 0;
}

#content-main {
	margin: 0;
	padding: 30px 0 20px 0;
}
#content-footer {
	font-family: "Century Gothic", "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	font-size: 13px;
	text-align: right;
	color: rgb(192, 80, 77);
/*	color: rgb(11, 83, 149); */
	margin: 30px 0 0 0;
    padding: 0;
	border-top: 4px solid rgb(12, 155, 116);
}
/*
 *  The main "header" & "footer" divisions
 */
.header-footer {
	font-family: "Century Gothic", "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	color: rgb(192, 80, 77);
/*	color: rgb(11, 83, 149); */
	font-size: 13px;
	text-align: right;
	margin: 10px 0 5px 0;
	padding: 5px 4px;
}
.header-footer a {
	color: rgb(192, 80, 77);
	text-decoration: underline;
}
.header-footer a:focus, .header-footer a:hover {  /* change color and remove underline */
	text-decoration: none;
 	color: rgb(11, 83, 149);
/*	color: rgb(192, 80, 77); */
}

h1, h2, h3, h4, h5, h6 {  /* main title and sub-title */
	font-family: "Century Gothic", "Trebuchet MS", "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	margin: 0;
	color: rgb(10, 132, 100);
	letter-spacing: 1px;
	line-height: 1.2;
	text-align:left;
}
h1 {
	font-size: 40px;
	font-weight: 400;
	padding: 0.2em 0;
}
h2 {
	font-size: 36px;
	font-weight: 400;
	padding: 0.2em 0;
}
h3 {
	font-size: 22px;
	border-bottom: thin solid rgb(12, 155, 116);
	padding: 1.5em 0 0.3em 0;
}
h4 {
	font-family: "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	font-size: 18px;
	padding: 1.3em 0 0.2em 0;
	border-bottom: thin dotted rgb(12, 155, 116);
}
h5, h6 {
	font-family: "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	font-size: 15px;
	color: #444;
	padding: 1.2em 0 0 0;  /* top right bottom left */
	letter-spacing: 1px;
}
.line-heading {
	color: #444;
	font-size: 15px;
	font-weight: bold;
	letter-spacing: 1px;
	padding: 0.2em 0;
}
.line-heading-code-new {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	color: #E31B23;
	font-size: 15px;
    font-weight: normal;
/*	letter-spacing: 0.5px; */
}
p {
	margin-top: 0.6em;
	margin-bottom: 0.4em;
}
pre {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	font-size: 13px;
	margin: 5px 0 8px 0;
	border: solid 2px #f8f8f8;  /* slight 3D shape */
	padding: 5px 10px;
	line-height: 135%;
}
code {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
}

ul {   /* first level ul */
	margin: 0.3em 0 0.2em 1.8em;
	padding: 0;
/*	list-style-type: square;  */
	list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAQMAAABBztZFAAAABlBMVEUAAwBjjJzG2b5OAAAAAXRSTlMAQObYZgAAABBJREFUCNdjYMAG7FARAwMADXkBNzRuJgIAAAAASUVORK5CYII=);
}
ul ul li {   /* 2nd level ul */
	list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAANAQMAAABb8jbLAAAABlBMVEX///8AUow5QSOjAAAAAXRSTlMAQObYZgAAABNJREFUCB1jYEABBQw/wLCAgQEAGpIDyT0IVcsAAAAASUVORK5CYII=);
/*
	list-style-type: disc;
	list-style-image: none; */
}
ul ul u1 li {   /* 3rd level ul */
	list-style-type: circle;
	list-style-image: none;
}
ol {   /* first level ol */
/*    list-style-position:inside; */
/*    display: table  */
    list-style-type: decimal;
	margin: 0.3em 0 0.2em 2.5em;
	padding: 0;
}
ol ol li {   /* 2nd level ol */
	list-style-type: lower-alpha;
}
ol ol o1 li {  /* 3rd level ol */
	list-style-type: lower-roman;
}

li {
	margin: 0.4em 0;
}

.float-left-ol-ul {
	overflow:hidden;
}

/* li after a left-float image */
.float-left-li {
   position: relative; left: 20px;
   margin-right: 20px;
}

a {
	color: rgb(11, 83, 149);
	text-decoration: none;
}
a:hover, a:focus {
	color: rgb(192, 80, 77);
	text-decoration: underline;
}

a.references {
	display: block;
	width: 30em;
	font-size: 18px;
	font-weight: bold;
	margin: 4em 0 0 0;
}

p.references {
	font-size: 18px;
	font-weight: bold;
	margin: 4em 0 0 0;
}

/*
 * General classes
 */
.center-block {
	margin: 10px auto;  /* auto margin-left and margin-right to center the table */
}
.text-center {	
    text-align: center; 
}
.text-right {	
    text-align: right; 
}
.underline {
	text-decoration: underline;
}
.font-code {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
}
.font-code-text {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	font-size: 14px;
}
.font-code-smaller {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	font-size: 13px;
}
.font-normal {
	font-family: "Segoe UI", Segoe, Calibri, "Ubuntu", Tahoma, Arial, Helvetica, Verdana, sans-serif;
}
.pre {
    white-space: pre;	
}
/* color control mainly for <pre>, <div>, <span> */
.color-example {
	background-color: rgb(215, 236, 211);  /* darker */
}
.color-example-light {
	background-color: rgb(236, 246, 234);  /* lighter */
}
.color-syntax, .color-command {
	background-color: rgb(204, 238, 241);  /* darker */
}
.color-explanation {
	background-color: #eee;   /* grey */
}
/* Character level control for code listing */
.color-comment {
	color: #009900;  /* green */
}
.color-new {
	color: #E31B23;  /* dark red to highlight new terms */
}
.color-error {
	color: #ff0099;  /* bright red */
/*	font-weight:bold; */
}
.color-plain {
	background-color: #fff;
}
.color-highlight {
	background-color: #ff0;
}
.color-highlight-new {
    background-color: #FFC;  /* lighter */
}

.output {  /* Output of program or DOS session */
    background-color: rgb(236, 246, 234);  /* lighter */
	border: solid 2px #f8f8f8;   /* slight 3D shape */
	padding: 4px 8px;
}
.side-note {
	margin-top: 15px;
    margin-left: 40px;
	padding: 3px 8px; 
	background-color: #e7e7e7;
}


/*
 * for positioning images 
 */
img.image-center {      /* center horizontally an image */
	display: block;
	margin: 10px auto;
}
img.image-border {
    border: #ddd thin solid;
}
img.image-float-left {
	float: left;
	margin: 8px 15px 15px 0;
    border: #ddd thin solid;
}
img.image-float-right {
	float: right;
	margin: 8px 0 15px 15px;
    border: #ddd thin solid;
}
.float-clear {
   clear: both;	
}
/*
 *  Table - for tablulating data with alternate row colors or different column colors
 */
table.table-zebra, table.table-program {
	border-collapse: collapse;
	border: 0;
	margin: 0 auto; /* center */
	padding: 0;
    width: 100%;
	/* Default setting for all cells in this table, inherited */
    background-color: rgb(231, 240, 248);  /* lighter */
	text-align: left;
	vertical-align: top;
}
table.table-zebra th {  /* header cells */
	color: #ffffff;     /* white text on dark background */
	background-color: rgb(0, 157, 217);
	margin: 0;
	border: 2px solid white;
	padding: 4px 10px;
	font-size: 15px;
	letter-spacing: 1px;
	text-align: center;
}
table.table-zebra td {  /* data cells */
    margin: 0;
	border: 2px solid white;
	padding: 2px 8px;
	/* color, font, text inherited from table */
	vertical-align: top;
}

table.table-program th {  /* header cells */
	color: #ffffff;     /* white text on dark background */
	background-color: rgb(0, 157, 217);
	margin: 0;
	border: 2px solid white;
	padding: 4px 10px;
	font-size: 15px;
	letter-spacing: 1px;
	text-align: center;
}
table.table-program td {  /* data cells */
    margin: 0;
	border: 0;
	padding: 0;
	/* color, font, text inherited from table */
}

table.table-program td pre {
	margin: 0;
	border: solid 2px #f8f8f8;   /* slight 3D shape */
	padding: 5px 10px;
}

table.table-program td pre.text-right {
	text-align: right;
}

/* Setting the color for row (2 colors) or column (3 colors) */
/* can only set the background, border, width of <col>, NOT font, text, color */
/* for table-zebra */
table .col-desc {       /* same as default color */
    background-color: rgb(231, 240, 248);  /* lighter */
}
table .col-code, table .tr-alt {
	background-color: rgb(203, 223, 241);  /* darker */
}
table .col-example {
    background-color: #eee;  /* grey */
}

/* for table-program */
table .col-line-number {
	width: 40px;
    background-color: rgb(225, 233, 207);
}
table .col-program {
    background-color: rgb(240, 244, 233);
}

/*
 * For the "Table of Content" generated by JavaScript
 * in <div id="toc">
 */
#wrap-toc {
    display: block;
	background: none repeat scroll 0 0 rgb(231, 246, 239);
	float: right;
	width: 230px;
	z-index: 100;
	line-height: 1.5;
	margin: 0 0 0 15px;
	padding: 5px 8px 10px 8px;
	text-align: left;
	white-space: nowrap;
/*	min-height: 180px;  */
}
#wrap-toc h5 {
   letter-spacing: 1px;
   margin: 0;
   text-transform: uppercase;
	color: #444;
	padding: 0.5em 0;
}
a#show-toc {
	color: rgb(192, 80, 77);
	text-decoration: none;
   letter-spacing: 1px;
}
#toc {
	overflow: auto;
}
#toc a.toc-H3 {
    margin-left: 0px;
	font-size: 15px;
}
#toc a.toc-H4 {
    margin-left: 20px;
	font-size: 14px;
}
#toc a.toc-H5 {
    margin-left: 40px;
	font-size: 14px;
}
</style>

<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAADy8O0APrMnACEdGADb2tkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMzMzMzMzMzMyIiIiIiIiIzIiIiIiIiIjMgIiIgAAAiMyACIiAAACIzIgAiIiIiIjMiIAIiIiIiMyIiACIiIiIzIiACIiIiIjMiACISEiESMyACIhISEiIzICIiERISIjMiIiISEhIiMyIiIhISIRIzIiIiIiIiIjMzMzMzMzMzMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" type="image/x-icon"></head>

<body class="">

<div id="wrap-outer" class="">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p class="">yet another insignificant programming notes... &nbsp;&nbsp;| &nbsp;&nbsp;<a href="http://www.ntu.edu.sg/home/ehchua/programming/index.html" class="">HOME</a></p></div>

<div id="wrap-inner" class="">

<div id="wrap-toc" class="">
<h5 class="">TABLE OF CONTENTS <a id="show-toc" href="#show-toc" class="">(HIDE)</a></h5>
<div id="toc" class=""><a class="toc-H3" href="#zz-1.">1.&nbsp;&nbsp;Overloaded Operators in the <span class="font-code">string</span> class</a><br class=""><a class="toc-H3" href="#zz-2.">2.&nbsp;&nbsp;User-defined Operator Overloading</a><br class=""><a class="toc-H4" href="#zz-2.1">2.1&nbsp;&nbsp;"<span class="font-code">operator</span>" Functions</a><br class=""><a class="toc-H4" href="#zz-2.2">2.2&nbsp;&nbsp;Example: Overloading <span class="font-code">'+'</span> Operator for the <span class="font-code">Point</span> Class as Member Function</a><br class=""><a class="toc-H4" href="#zz-2.3">2.3&nbsp;&nbsp;Restrictions on Operator Overloading</a><br class=""><a class="toc-H3" href="#zz-3.">3.&nbsp;&nbsp;Overloading Operator via "<span class="font-code">friend</span>" non-member function</a><br class=""><a class="toc-H4" href="#zz-3.1">3.1&nbsp;&nbsp;Why can't we always use Member Function for Operator Overloading?</a><br class=""><a class="toc-H4" href="#zz-3.2">3.2&nbsp;&nbsp;"<span class="font-code">friend</span>" Functions</a><br class=""><a class="toc-H4" href="#zz-3.3">3.3&nbsp;&nbsp;Example: Overloading <span class="font-code">&lt;&lt;</span> and <span class="font-code">&gt;&gt;</span> Operators of <span class="font-code">Point</span> class using non-member <span class="font-code">friend</span> Functions</a><br class=""><a class="toc-H3" href="#zz-4.">4.&nbsp;&nbsp;Overloading Binary Operators</a><br class=""><a class="toc-H3" href="#zz-5.">5.&nbsp;&nbsp;Overloading Unary Operators</a><br class=""><a class="toc-H4" href="#zz-5.1">5.1&nbsp;&nbsp;Unary Prefix Operator</a><br class=""><a class="toc-H4" href="#zz-5.2">5.2&nbsp;&nbsp;Unary Postfix Operator</a><br class=""><a class="toc-H4" href="#zz-5.3">5.3&nbsp;&nbsp;Example: Overloading Prefix and Postfix <span class="font-code">++</span> for the <span class="font-code">Counter</span> Class</a><br class=""><a class="toc-H3" href="#zz-6.">6.&nbsp;&nbsp;Example: Putting them together in <span class="font-code">Point</span> Class</a><br class=""><a class="toc-H3" href="#zz-7.">7.&nbsp;&nbsp;Implicit Conversion via Single-argument Constructor &amp; Keyword "<span class="font-code">explicit</span>"</a><br class=""><a class="toc-H3" href="#zz-8.">8.&nbsp;&nbsp;Example: The <span class="font-code">MyComplex</span> Class</a><br class=""><a class="toc-H3" href="#zz-9.">9.&nbsp;&nbsp;Dynamic Memory Allocation in Object</a><br class=""><a class="toc-H4" href="#zz-9.1">9.1&nbsp;&nbsp;Example: <span class="font-code">MyDynamicArray</span></a><br class=""><br class=""></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header" class="">
<h1 class="">C++ Programming Language</h1>
<h2 class="">Operator Overloading</h2>
</div>

<div id="content-main" class="">

<p class="">Operator overloading means that the operation performed by the operator depends on the <em class="">type</em> of operands provided to the operator. For example, (a) the bit left-shift operator <code class="">&lt;&lt;</code> is overloaded to perform stream insertion if the left operand is a <code class="">ostream</code> object such as <code class="">cout</code>; (b) the operator <code class="">*</code> could means multiplication for two numbers of built-in types or indirection if it operates on an address. C++ lets you extend operator overloading to user-defined types (classes).</p>
<p class="">Operator overloading is similar to function overloading, where you have many versions of the same function differentiated by their parameter lists.</p>

<h3 class="">1.&nbsp;&nbsp;Overloaded Operators in the <span class="font-code">string</span> class<a id="zz-1." class="" style=""></a></h3>

<p class="">As an example, the C++ <code class="">string</code> class (in header <code class="">&lt;string&gt;</code>) overloads these operators to work on <code class="">string</code> objects:</p>

<ul class="">
<li class="">String comparison (<code class="">==</code>, <code class="">!=</code>, <code class="">&gt;</code>, <code class="">&lt;</code>, <code class="">&gt;=</code>, <code class="">&lt;=</code>): For example, you can use <code class="">str1 == str2</code> to compare the contents of two <code class="">string</code> objects.</li>
<li class="">Stream insertion and extraction (<code class="">&lt;&lt;</code>, <code class="">&gt;&gt;</code>): For example, you can use <code class="">cout &lt;&lt; str1</code> and <code class="">cin &gt;&gt; str2</code> to output/input <code class="">string</code> objects.</li>
<li class="">Strings concatenation (<code class="">+</code>, <code class="">+=</code>): For example, <code class="">str1 + str2</code> concatenates two <code class="">string</code> objects to produce a new <code class="">string</code> object; <code class="">str1 += str2</code> appends <code class="">str2</code> into <code class="">str1</code>.</li>
<li class=""> Character indexing or subscripting <code class="">[]</code>: For example, you can use <code class="">str[<em class="">n</em>]</code> to get the <code class="">char</code> at index <code class=""><em class="">n</em></code>; or <code class="">str[<em class="">n</em>] = c</code> to  modify the <code class="">char</code> at index <code class=""><em class="">n</em></code>. Take note that <code class="">[]</code> operator does not perform index-bound check, i.e., you have to ensure that the index is within the bounds. To perform index-bound check, you can use <code class="">string</code>'s <code class="">at()</code> member function.</li>
<li class="">Assignment (<code class="">=</code>): For example, <code class="">str1 = str2</code> assigns <code class="">str2</code> into <code class="">str1</code>.</li>
</ul>

<h5 class="">Example</h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* Test overloaded operators in the C++ string class
   (TestStringOverloadOperators.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;   <span class="color-comment"> // needed to use the string class</span>
using namespace std;
 
int main() {
   string msg1("hello");
   string msg2("HELLO");
   string msg3("hello");
 
  <span class="color-comment"> // Relational Operators (comparing the contents)</span>
   cout &lt;&lt; boolalpha;
   cout &lt;&lt; (msg1 == msg2) &lt;&lt; endl; <span class="color-comment"> // false</span>
   cout &lt;&lt; (msg1 == msg3) &lt;&lt; endl; <span class="color-comment"> // true</span>
   cout &lt;&lt; (msg1 &lt; msg2)  &lt;&lt; endl; <span class="color-comment"> // false (uppercases before lowercases)</span>
 
  <span class="color-comment"> // Assignment</span>
   string msg4 = msg1;
   cout &lt;&lt; msg4 &lt;&lt; endl; <span class="color-comment"> // hello</span>
 
  <span class="color-comment"> // Concatenation</span>
   cout &lt;&lt; (msg1 + " " + msg2) &lt;&lt; endl; <span class="color-comment"> // hello HELLO</span>
   msg3 += msg2;
   cout &lt;&lt; msg3 &lt;&lt; endl; <span class="color-comment"> // helloHELLO</span>
 
  <span class="color-comment"> // Indexing</span>
   cout &lt;&lt; msg1[1] &lt;&lt; endl;    <span class="color-comment"> // 'e'</span>
   cout &lt;&lt; msg1[99] &lt;&lt; endl;   <span class="color-comment"> // garbage (no index-bound check)</span>
<span class="color-comment">// cout &lt;&lt; msg1.at(99) &lt;&lt; endl;<span class="color-comment"> // out_of_range exception</span></span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p class=""><span class="line-heading">Notes</span>: The relational operators (<code class="">==</code>, <code class="">!=</code>, <code class="">&gt;</code>, <code class="">&lt;</code>, <code class="">&gt;=</code>, <code class="">&lt;=</code>), <code class="">+</code>, <code class="">&lt;&lt;</code>, <code class="">&gt;&gt;</code> are overloaded as non-member functions, where the left operand could be a non-<code class="">string</code> object (such as C-string, <code class="">cin</code>, <code class="">cout</code>); while <code class="">=</code>, <code class="">[]</code>, <code class="">+=</code> are overloaded as member functions where the left operand must be a <code class="">string</code> object. I shall elaborate later.</p>

<h3 class="">2.&nbsp;&nbsp;User-defined Operator Overloading<a id="zz-2." class="" style=""></a></h3>

<h4 class="">2.1&nbsp;&nbsp;"<span class="font-code">operator</span>" Functions<a id="zz-2.1" class="" style=""></a></h4>

<p class="">To overload an operator, you use a special function form called an <em class="">operator function</em>, in the form of <code class="">operatorΔ()</code>, where <code class="">Δ</code> denotes the operator to be overloaded:</p>

<pre class="color-syntax"><em class="">return-type</em> <strong class="">operator</strong>Δ(<em class="">parameter-list</em>)</pre>

<p class="">For example, <code class="">operator+()</code> overloads the <code class="">+</code> operator; <code class="">operator&lt;&lt;()</code> overloads the <code class="">&lt;&lt;</code> operator. Take note that <code class="">Δ</code> must be an existing C++ operator. You cannot create you own operator.</p>

<h4 class="">2.2&nbsp;&nbsp;Example: Overloading <span class="font-code">'+'</span> Operator for the <span class="font-code">Point</span> Class as Member Function<a id="zz-2.2" class="" style=""></a></h4>

<p class="">In this example, we shall overload the <code class="">'+'</code> operator in the <code class="">Point</code> class to support addition of two <code class="">Point</code> objects. In other words, we can write <code class="">p3 = p1+p2</code>, where <code class="">p1</code>, <code class="">p2</code> and <code class="">p3</code> are <code class="">Point</code> objects, similar to the usual arithmetic operation. We shall construct a new <code class="">Point</code> instance <code class="">p3</code> for the sum, without changing the <code class="">p1</code> and <code class="">p2</code> instances.</p>

<h5 class=""><span class="font-code">Point.h</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* The Point class Header file (Point.h) */</span>
#ifndef POINT_H
#define POINT_H
 
class Point {
private:
   int x, y;<span class="color-comment"> // Private data members</span>
 
public:
   Point(int x = 0, int y = 0);<span class="color-comment"> // Constructor</span>
   int getX() const;<span class="color-comment"> // Getters</span>
   int getY() const;
   void setX(int x);<span class="color-comment"> // Setters</span>
   void setY(int y);
   void print() const;
   <span class="color-new">const Point operator+(const Point &amp; rhs) const;</span>
         <span class="color-comment">// Overload '+' operator as member function of the class</span>
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">We overload the <code class="">+</code> operator via a member function <code class="">operator+()</code>, which shall add this instance (left operand) with the <code class="">rhs</code> operand, construct a new instance containing the sum and and return it <em class="">by value</em>. We cannot return by reference a local variable created inside the function, as the local variable would be destroyed when the function exits.</li>
<li class="">The <code class="">rhs</code> operand is passed by reference for performance.</li>
<li class="">The member function is declared <code class="">const</code>, which cannot modify data members.</li>
<li class="">The return value is declared <code class="">const</code>, so as to prevent it from being used as <em class="">lvalue</em>. For example, it prevents writing <code class="">(p1+p2) = p3</code>, which is meaningless and could be due to misspelling <code class="">(p1+p2) == p3</code>.</li>
</ul>

<h5 class=""><span class="font-code">Point.cpp</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* The Point class Implementation file (Point.cpp) */</span>
#include "Point.h"
#include &lt;iostream&gt;
using namespace std;
 
<span class="color-comment">// Constructor - The default values are specified in the declaration</span>
Point::Point(int x, int y) : x(x), y(y) { }<span class="color-comment"> // Using initializer list</span>
 
<span class="color-comment">// Getters</span>
int Point::getX() const { return x; }
int Point::getY() const { return y; }
 
<span class="color-comment">// Setters</span>
void Point::setX(int x) { this-&gt;x = x; }
void Point::setY(int y) { this-&gt;y = y; }
 
<span class="color-comment">// Public Functions</span>
void Point::print() const {
   cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")" &lt;&lt; endl;
}
 
<span class="color-comment">// Member function overloading '+' operator</span>
<span class="color-new">const Point Point::<strong class="">operator+</strong>(const Point &amp; rhs) const {
   return Point(x + rhs.x, y + rhs.y);
}</span></pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">The function allocates a new <code class="">Point</code> object with the sums of <code class="">x</code>'s and <code class="">y</code>'s, and returns this object by <code class="">const</code> value.</li>
</ul>

<h5 class=""><span class="font-code">TestPoint.cpp</span></h5>
<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre>
</td>
<td class="">
<pre class="">#include "Point.h"
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   Point p1(1, 2), p2(4, 5);
  <span class="color-comment"> // Use overloaded operator +</span>
   Point p3 = <span class="color-new">p1 + p2</span>;
   p1.print(); <span class="color-comment"> // (1,2)</span>
   p2.print(); <span class="color-comment"> // (4,5)</span>
   p3.print(); <span class="color-comment"> // (5,7)</span>
 
  <span class="color-comment"> // Invoke via usual dot syntax, same as p1+p2</span>
   Point p4 = <span class="color-new">p1.operator+(p2)</span>;
   p4.print(); <span class="color-comment"> // (5,7)</span>
 
  <span class="color-comment"> // Chaining</span>
   Point p5 = <span class="color-new">p1 + p2 + p3 + p4</span>;
   p5.print(); <span class="color-comment"> // (15,21)</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">You can invoke the overloaded operator via <code class="">p1+p2</code>, which will be translated into the dot operation <code class="">p1.operator+(p2)</code>.</li>
<li class="">The <code class="">+</code> operator supports chaining (cascading) operations, as <code class="">p1+p2</code> returns a <code class="">Point</code> object.</li>

</ul>

<h4 class="">2.3&nbsp;&nbsp;Restrictions on Operator Overloading<a id="zz-2.3" class="" style=""></a></h4>

<ul class="">
<li class="">The overloaded operator must be an existing and valid operator. You cannot create your own operator such as ⊕.</li>

<li class="">Certain C++ operators cannot be overloaded, such as <code class="">sizeof</code>, dot (<code class="">.</code> and <code class="">.*</code>), scope resolution (<code class="">::</code>) and conditional (<code class="">?:</code>).</li>

<li class="">The overloaded operator must have at least one operands of the user-defined types. You cannot overload an operator working on fundamental types. That is, you can't overload the <code class="">'+'</code> operator for two <code class="">int</code>s (fundamental type) to perform subtraction.</li>

<li class="">You cannot change the syntax rules (such as associativity, precedence and number of arguments) of the overloaded operator.</li>
</ul>

<h3 class="">3.&nbsp;&nbsp;Overloading Operator via "<span class="font-code">friend</span>" non-member function<a id="zz-3." class="" style=""></a></h3>

<h4 class="">3.1&nbsp;&nbsp;Why can't we always use Member Function for Operator Overloading?<a id="zz-3.1" class="" style=""></a></h4>

<p class="">The<code class="" style=""> </code>member function <code class="">operatorΔ()</code> can only be invoked from an object via the dot operator, e.g., <code class="">p1.operatorΔ(p2)</code>, which is equivalent to <code class="">p1 Δ p2</code>. Clearly the left operand <code class="">p1</code> should be an object of that particular class. Suppose that we want to overload a binary operator such as <code class="">*</code> to multiply the object <code class="">p1</code> with an <code class="">int</code> literal, <code class="">p1*5</code> can be translated into <code class="">p1.operator*(5)</code>, but <code class="">5*p1<span class="color-comment" style=""></span></code> cannot be represented using member function. One way to deal with this problem is only allow user to write <code class="">p1*5</code> but not <code class="">5*p1</code>, which is not user friendly and break the rule of commutativity. Another way is to use a non-member function, which does not invoke through an object and dot operator, but through the arguments provided. For example, <code class="">5*p1<span class="color-comment" style=""></span></code> could be translated to <code class="">operator+(5, p1)</code>.</p>

<p class="">In brief, you cannot use member function to overload an operator if the left operand is not an object of that particular class.</p>

<h4 class="">3.2&nbsp;&nbsp;"<span class="font-code">friend</span>" Functions<a id="zz-3.2" class="" style=""></a></h4>

<p class="">A regular non-member function cannot directly access the private data of the objects given in its arguments. A special type of function, called <code class="">friend</code>s, are allowed to access the private data.</p>

<p class="">A "friend" function of a class, marked by the keyword <code class="">friend</code>, is a function defined outside the class, yet its argument of that class has unrestricted access to all the class members (<code class="">private</code>, <code class="">protected</code> and <code class="">public</code> data members and member functions). Friend functions can enhance the performance, as they eliminate the need of calling public member functions to access the private data members.</p>


<h4 class="">3.3&nbsp;&nbsp;Example: Overloading <span class="font-code">&lt;&lt;</span> and <span class="font-code">&gt;&gt;</span> Operators of <span class="font-code">Point</span> class using non-member <span class="font-code">friend</span> Functions<a id="zz-3.3" class="" style=""></a></h4>


<p class="">In this example, we shall overload <code class="">&lt;&lt;</code> and <code class="">&gt;&gt;</code> operators to support stream insertion and extraction of <code class="">Point</code> objects, i.e., <code class="">cout &lt;&lt; <em class="">aPoint</em></code>, and <code class="">cin &gt;&gt; <em class="">aPoint</em></code>. Since the left operand is not a <code class="">Point</code> object (<code class="">cout</code> is an <code class="">ostream</code> object and <code class="">cin</code> is an <code class="">istream</code> object), we cannot use member function, but need to use non-member<code class="" style=""> </code>function for operator overloading. We shall make these functions <code class="">friend</code>s of the <code class="">Point</code> class, to allow them to access the private data members directly for enhanced performance.</p>

<h5 class=""><span class="font-code">Point.h</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* The Point class Header file (Point.h) */</span>
#ifndef POINT_H
#define POINT_H
 
#include &lt;iostream&gt;
 
<span class="color-comment">// Class Declaration</span>
class Point {
private:
   int x, y;
 
public:
   Point(int x = 0, int y = 0);
   int getX() const;<span class="color-comment"> // Getters</span>
   int getY() const;
   void setX(int x);<span class="color-comment"> // Setters</span>
   void setY(int y);
 
   <span class="color-new">friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const Point &amp; point);
   friend std::istream &amp; operator&gt;&gt;(std::istream &amp; in, Point &amp; point);</span>
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">Friends are neither <code class="">public</code> or <code class="">private</code>, and can be listed anywhere within the class declaration.</li>

<li class="">The <code class="">cout</code> and <code class="">cin</code> need to be passed into the function by reference, so that the function accesses the <code class="">cout</code> and <code class="">cin</code> directly (instead of a clone copy by value).</li>

<li class="">We return the <code class="">cin</code> and <code class="">cout</code> passed into the function by reference too, so as to support cascading operations. For example, <code class="">cout &lt;&lt; p1 &lt;&lt; endl</code> will be interpreted as <code class="">(cout &lt;&lt; p1) &lt;&lt; endl</code>.</li>
<li class="">In <code class="">&lt;&lt;</code>, the reference parameter <code class="">Point</code> is declared as <code class="">const</code>. Hence, the function cannot modify the <code class="">Point</code> object. On the other hand, in <code class="">&gt;&gt;</code>, the <code class="">Point</code> reference is non-const, as it will be modified to keep the input.</li>
<li class="">We use fully-qualified name <code class="">std::istream</code> instead of placing a "<code class="">using namespace std;</code>" statement in the header. It is because this header could be included in many files, which would include the <code class="">using</code> statement too and may not be desirable.</li>

</ul>

<h5 class=""><span class="font-code">Point.cpp</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></td>
<td class="">
<pre class=""><span class="color-comment">/* The Point class Implementation file (Point.cpp) */</span>
#include &lt;iostream&gt;
#include "Point.h"
using namespace std;
 
<span class="color-comment">// Constructor - The default values are specified in the declaration</span>
Point::Point(int x, int y) : x(x), y(y) { }<span class="color-comment"> // using member initializer list</span>
 
<span class="color-comment">// Getters</span>
int Point::getX() const { return x; }
int Point::getY() const { return y; }
 
<span class="color-comment">// Setters</span>
void Point::setX(int x) { this-&gt;x = x; }
void Point::setY(int y) { this-&gt;y = y; }
 
<span class="color-new">ostream &amp; operator&lt;&lt;(ostream &amp; out, const Point &amp; point) {
   out &lt;&lt; "(" &lt;&lt; point.x &lt;&lt; "," &lt;&lt; point.y &lt;&lt; ")";  <span class="color-comment">// access private data</span>
   return out;
}
 
istream &amp; operator&gt;&gt;(istream &amp; in, Point &amp; point) {
   cout &lt;&lt; "Enter x and y coord: ";
   in &gt;&gt; point.x &gt;&gt; point.y;  <span class="color-comment">// access private data</span>
   return in;
}</span></pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">The function definition does not require the keyword <code class="">friend</code>, and the <code class=""><em class="">ClassName</em>::</code> scope resolution qualifier, as it does not belong to the class.</li>

<li class="">The <code class="">operator&lt;&lt;()</code> function is declared as a friend of <code class="">Point</code> class. Hence, it can access the private data members <code class="">x</code> and <code class="">y</code> of its argument <code class="">Point</code> directly.  <code class="">operator&lt;&lt;()</code> function is NOT a friend of <code class="">ostream</code> class, as there is no need to access the private member of <code class="">ostream</code>.</li>

<li class="">Instead of accessing private data member <code class="">x</code> and <code class="">y</code> directly, you could use public member function <code class="">getX()</code> and <code class="">getY()</code>. In this case, there is no need to declare <code class="">operator&lt;&lt;()</code> as a friend of the <code class="">Point</code> class. You could simply declare a regular function prototype in the header.
<pre class="color-example"><span class="color-comment">// Function prototype</span>
ostream &amp; operator&lt;&lt;(ostream &amp; out, const Point &amp; point);
 
<span class="color-comment">// Function definition</span>
ostream &amp; operator&lt;&lt;(ostream &amp; out, const Point &amp; point) {
   out &lt;&lt; "(" &lt;&lt; <span class="color-new">point.getX()</span> &lt;&lt; "," &lt;&lt; <span class="color-new">point.getY()</span> &lt;&lt; ")";
   return out;
}</pre>
Using <code class="">friend</code> is recommended, as it enhances performance. Furthermore, the overloaded operator becomes part of the extended public interface of the class, which helps in ease-of-use and ease-of-maintenance.</li>
</ul>

<h5 class=""><span class="font-code">TestPoint.cpp</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21</pre>
</td>
<td class="">
<pre class="">#include &lt;iostream&gt;
#include "Point.h"
using namespace std;
 
int main() {
   Point p1(1, 2), p2;
 
  <span class="color-comment"> // Using overloaded operator &lt;&lt;</span>
   <span class="color-new">cout &lt;&lt; p1</span> &lt;&lt; endl;   <span class="color-comment"> // support cascading</span>
   <span class="color-new">operator&lt;&lt;(cout, p1)</span>; <span class="color-comment"> // same as cout &lt;&lt; p1</span>
   cout &lt;&lt; endl;
 
  <span class="color-comment"> // Using overloaded operator &gt;&gt;</span>
   <span class="color-new">cin &gt;&gt; p1</span>;
   cout &lt;&lt; p1 &lt;&lt; endl;
   <span class="color-new">operator&gt;&gt;(cin, p1)</span>; <span class="color-comment"> // same as cin &gt;&gt; p1</span>
   cout &lt;&lt; p1 &lt;&lt; endl;
   <span class="color-new">cin &gt;&gt; p1 &gt;&gt; p2</span>;     <span class="color-comment"> // support cascading</span>
   cout &lt;&lt; p1 &lt;&lt; endl;
   cout &lt;&lt; p2 &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="">The overloaded <code class="">&gt;&gt;</code> and <code class="">&lt;&lt;</code> can also be used for file input/output, as the file IO stream <code class="">ifstream/ofstream</code> (in <code class="">fstream</code> header) is a subclass of <code class="">istream/ostream</code>. For example,</p>

<pre class="color-example">#include &lt;fstream&gt;
#include "Point.h"
using namespace std;
 
int main() {
   Point p1(1, 2);
 
   <span class="color-new">ofstream fout("out.txt");</span>
   <span class="color-new">fout &lt;&lt; p1</span> &lt;&lt; endl;
 
   <span class="color-new">ifstream fin("in.txt");</span><span class="color-comment"> // contains "3 4"</span>
   <span class="color-new">fin &gt;&gt; p1;</span>
   cout &lt;&lt; p1 &lt;&lt; endl;
}</pre>

<h3 class="">4.&nbsp;&nbsp;Overloading Binary Operators<a id="zz-4." class="" style=""></a></h3>

<p class="">All C++ operators are either <em class="">binary</em> (e.g., <code class="">x + y</code>) or <em class="">unary</em> (e.g. <code class="">!x</code>, <code class="">-x</code>), with the exception of <em class="">tenary</em> conditional operator (<code class="">? :</code>) which cannot be overloaded.</p>

<p class="">Suppose that we wish to overload the binary operator <code class="">==</code> to compare two <code class="">Point</code> objects. We could do it as a <em class="">member function</em>  or <em class="">non-member function</em>.</p>

<ol class="">
<li class="">To overload as a <em class="">member function</em>, the declaration is as follows:
  <pre class="color-example">class Point {
public:
   <span class="color-new">bool operator==(const Point &amp; rhs) const;</span>  <span class="color-comment">// p1.operator==(p2)</span>
   ......
};</pre>

The compiler translates "<code class="">p1 == p2</code>" to "<code class="">p1.operator==(p2)</code>", as a member function call of object <code class="">p1</code>, with argument <code class="">p2</code>.<br class="">

<p class="">Member function can only be used if the left operand is an object of that particular class.</p>

</li>

<li class="">To overload as a <em class="">non-member function</em>, which is often declared as a <code class="">friend</code> to access the private data for enhanced performance, the declaration is as follows:
  <pre class="color-example">class Point {
   <span class="color-new">friend bool operator==(const Point &amp; lhs, const Point &amp; rhs);</span> <span class="color-comment">// operator==(p1,p2)</span>
   ......
};</pre>

The compiler translates the expression "<code class="">p1 == p2</code>" to "<code class="">operator==(p1, p2)</code>".</li>
</ol>

<h3 class="">5.&nbsp;&nbsp;Overloading Unary Operators<a id="zz-5." class="" style=""></a></h3>

<p class="">Most of the unary operators are prefix operators, e.g., <code class="">!x</code>, <code class="">-x</code>. Hence, prefix is the norm for unary operators. However, unary increment and decrement come in two forms: prefix (<code class="">++x</code>, <code class="">--x</code>) and postfix (<code class="">x++</code>, <code class="">x--</code>). We to a mechanism to differentiate the two forms.</p>

<h4 class="">5.1&nbsp;&nbsp;Unary Prefix Operator<a id="zz-5.1" class="" style=""></a></h4>

<p class="">Example of unary prefix operators are <code class="">!x</code>, <code class="">-x</code>, <code class="">++x</code> and <code class="">--x</code>. You could do it as a non-member function as well as member function. For example, to overload the prefix increment operator <code class="">++</code>:</p>

<ol class="">
<li class="">To overload as a non-member <code class="">friend</code> function:
<pre class="color-example">class Point {
   <span class="color-new">friend Point &amp; operator++(Point &amp; point);</span>
   ......
};</pre>

The compiler translates "<code class="">++p</code>" to "<code class="">operator++(p)</code>".</li>

<li class="">To overload as a member function:
<pre class="color-example">class Point {
public:
   <span class="color-new">Point &amp; operator++();</span>  <span class="color-comment">// this Point</span>
   ......
};</pre>

The compiler translates "<code class="">++p</code>" to "<code class="">p.operator++()</code>".</li>
</ol>

<p class="">You can use either member function or non-member friend function to overload unary operators, as their only operand shall be an object of that class.</p>

<h4 class="">5.2&nbsp;&nbsp;Unary Postfix Operator<a id="zz-5.2" class="" style=""></a></h4>

<p class="">The unary increment and decrement operators come in two forms: prefix (<code class="">++x</code>, <code class="">--x</code>) and postfix (<code class="">x++</code>, <code class="">x--</code>). Overloading postfix operators (such as <code class="">x++</code>, x--) present a challenge. It ought to be differentiated from the prefix operator (<code class="">++x</code>, <code class="">--x</code>). A "dummy" argument is therefore introduced to indicate postfix operation as shown below. Take note that postfix <code class="">++</code> shall save the old value, perform the increment, and then return the saved value by value.</p>

<ol class="">
<li class="">To overload as non-member <code class="">friend</code> function:
<pre class="color-example">class Point {
   <span class="color-new">friend const Point operator++(Point &amp; point, int dummy);</span>
};</pre>

The compiler translates "<code class="">pt++</code>" to "<code class="">operator++(pt, 0)</code>". The <code class="">int</code> argument is strictly a <em class="">dummy value</em> to differentiate prefix from postfix operation.</li>

<li class="">To overload as a member function:
<pre class="color-example">class Point {
public:
   <span class="color-new">const Point operator++(int dummy);</span>  <span class="color-comment">// this Point</span>
   ......
};</pre>

The compiler translates "<code class="">pt++</code>" to "<code class="">pt.operator++(0)</code>".</li>
</ol>

<h4 class="">5.3&nbsp;&nbsp;Example: Overloading Prefix and Postfix <span class="font-code">++</span> for the <span class="font-code">Counter</span> Class<a id="zz-5.3" class="" style=""></a></h4>

<h5 class=""><span class="font-code">Counter.h</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* The Counter class Header file (Counter.h) */</span>
#ifndef COUNTER_H
#define COUNTER_H
#include &lt;iostream&gt;
 
class Counter {
private:
   int count;
public:
   Counter(int count = 0);  <span class="color-comment"> // Constructor</span>
   int getCount() const;     <span class="color-comment">// Getters</span>
   void setCount(int count);<span class="color-comment"> // Setters</span>
   <span class="color-new">Counter &amp; operator++();</span>             <span class="color-comment"> // ++prefix</span>
   <span class="color-new">const Counter operator++(int dummy);</span><span class="color-comment"> // postfix++</span>
 
   friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const Counter &amp; counter);
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">The prefix function returns a reference to this instance, to support chaining (or cascading), e.g., <code class="">++++c</code> as <code class="">++(++c)</code>. However, the return reference can be used as lvalue with unexpected operations (e.g., <code class="">++c = 8</code>).</li>
<li class="">The postfix function returns a <code class="">const</code> object by value. A <code class="">const</code> value cannot be used as lvalue. This prevents chaining such as <code class="">c++++</code>. Although it would be interpreted as <code class="">(c++)++</code>. However, <code class="">(c++)</code> does not return this object, but an temporary object. The subsequent <code class="">++</code> works on the temporary object.</li>
<li class="">Both prefix and postfix functions are non-<code class="">const</code>, as they modify the data member <code class="">count</code>.</li>

</ul>

<h5 class=""><span class="font-code">Counter.cpp</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* The Counter class Implementation file (Counter.cpp) */</span>
#include "Counter.h"
#include &lt;iostream&gt;
using namespace std;
 
<span class="color-comment">// Constructor - The default values are specified in the declaration</span>
Counter::Counter(int c) : count(c) { }<span class="color-comment"> // using member initializer list</span>
 
<span class="color-comment">// Getters</span>
int Counter::getCount() const { return count; }
 
<span class="color-comment">// Setters</span>
void Counter::setCount(int c) { count = c; }
 
<span class="color-comment">// ++prefix, return reference of this</span>
<span class="color-new">Counter &amp; Counter::operator++() {
   ++count;
   return *this;
}</span>
 
<span class="color-comment">// postfix++, return old value by value</span>
<span class="color-new">const Counter Counter::operator++(int dummy) {
   Counter old(*this);
   ++count;
   return old;
}</span>
 
<span class="color-comment">// Overload stream insertion &lt;&lt; operator</span>
ostream &amp; operator&lt;&lt;(ostream &amp; out, const Counter &amp; counter) {
   out &lt;&lt; counter.count;
   return out;
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">The prefix function increments the <code class="">count</code>, and returns this object by reference.</li>
<li class="">The postfix function saves the old value (by constructing a new instance with this object via the copy constructor), increments the <code class="">count</code>, and return the saved object by value.</li>
<li class="">Clearly, postfix operation on object is less efficient than the prefix operation, as it create a temporary object. If there is no subsequent operation that relies on the output of prefix/postfix operation, use prefix operation.</li>
</ul>

<h5 class=""><span class="font-code">TestCounter.cpp</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre>
</td>
<td class="">
<pre class="">#include "Counter.h"
#include &lt;iostream&gt;
using namespace std;
 
int main() {
   Counter c1;
   cout &lt;&lt; c1 &lt;&lt; endl;    <span class="color-comment"> // 0</span>
   cout &lt;&lt; <span class="color-new">++c1</span> &lt;&lt; endl;  <span class="color-comment"> // 1</span>
   cout &lt;&lt; c1 &lt;&lt; endl;    <span class="color-comment"> // 1</span>
   cout &lt;&lt; <span class="color-new">c1++</span> &lt;&lt; endl;  <span class="color-comment"> // 1</span>
   cout &lt;&lt; c1 &lt;&lt; endl;    <span class="color-comment"> // 2</span>
   cout &lt;&lt; <span class="color-new">++++c1</span> &lt;&lt; endl;<span class="color-comment"> // 4</span>
<span class="color-comment">//</span> cout &lt;&lt; <span class="color-new">c1++++</span> &lt;&lt; endl;<span class="color-comment"> // error caused by const return value</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">Take note of the difference in <code class="">cout &lt;&lt; c1++</code> and <code class="">cout &lt;&lt; ++c1</code>. Both prefix and postfix operators work as expected.</li>
<li class=""><code class="">++++c1</code> is allowed and works correctly. <code class="">c1++++</code> is disallowed, because it would produce incorrect result.</li>

</ul>


<h3 class="">6.&nbsp;&nbsp;Example: Putting them together in <span class="font-code">Point</span> Class<a id="zz-6." class="" style=""></a></h3>

<p class="">This example overload binary operator <code class="">&lt;&lt;</code> and <code class="">&gt;&gt;</code> as non-member functions for stream insertion and stream extraction. It also overload unary <code class="">++</code> (postfix and prefix) and binary <code class="">+=</code> as member function; and <code class="">+</code>, <code class="">+=</code> operators.</p>

<h5 class=""><span class="font-code">Point.h</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* The Point class Header file (Point.h) */</span>
#ifndef POINT_H
#define POINT_H
#include &lt;iostream&gt;
 
class Point {
private:
   int x, y;
 
public:
   explicit Point(int x = 0, int y = 0);
   int getX() const;
   int getY() const;
   void setX(int x);
   void setY(int y);
   Point &amp; operator++();             <span class="color-comment"> // ++prefix</span>
   const Point operator++(int dummy);<span class="color-comment"> // postfix++</span>
   const Point operator+(const Point &amp; rhs) const;<span class="color-comment"> // Point + Point</span>
   const Point operator+(int value) const;          <span class="color-comment"> // Point + int</span>
   Point &amp; operator+=(int value);          <span class="color-comment"> // Point += int</span>
   Point &amp; operator+=(const Point &amp; rhs);<span class="color-comment"> // Point += Point</span>
 
   friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; out, const Point &amp; point); <span class="color-comment">// out &lt;&lt; point</span>
   friend std::istream &amp; operator&gt;&gt;(std::istream &amp; in, Point &amp; point);        <span class="color-comment">// in &gt;&gt; point</span>
   friend const Point operator+(int value, const Point &amp; rhs);<span class="color-comment"> // int + Point</span>
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<h5 class=""><span class="font-code">Point.cpp</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* The Point class Implementation file (Point.cpp) */</span>
#include "Point.h"
#include &lt;iostream&gt;
using namespace std;
 
<span class="color-comment">// Constructor - The default values are specified in the declaration</span>
Point::Point(int x, int y) : x(x), y(y) { }
 
<span class="color-comment">// Getters</span>
int Point::getX() const { return x; }
int Point::getY() const { return y; }
 
<span class="color-comment">// Setters</span>
void Point::setX(int x) { this-&gt;x = x; }
void Point::setY(int y) { this-&gt;y = y; }
 
<span class="color-comment">// Overload ++Prefix, increase x, y by 1</span>
Point &amp; Point::operator++() {
   ++x;
   ++y;
   return *this;
}
 
<span class="color-comment">// Overload Postfix++, increase x, y by 1</span>
const Point Point::operator++(int dummy) {
   Point old(*this);
   ++x;
   ++y;
   return old;
}
 
<span class="color-comment">// Overload Point + int. Return a new Point by value</span>
const Point Point::operator+(int value) const {
   return Point(x + value, y + value);
}
 
<span class="color-comment">// Overload Point + Point. Return a new Point by value</span>
const Point Point::operator+(const Point &amp; rhs) const {
   return Point(x + rhs.x, y + rhs.y);
}
 
<span class="color-comment">// Overload Point += int. Increase x, y by value</span>
Point &amp; Point::operator+=(int value) {
   x += value;
   y += value;
   return *this;
}
 
<span class="color-comment">// Overload Point += Point. Increase x, y by rhs</span>
Point &amp; Point::operator+=(const Point &amp; rhs) {
   x += rhs.x;
   y += rhs.y;
   return *this;
}
 
<span class="color-comment">// Overload &lt;&lt; stream insertion operator</span>
ostream &amp; operator&lt;&lt;(ostream &amp; out, const Point &amp; point) {
   out &lt;&lt; "(" &lt;&lt; point.x &lt;&lt; "," &lt;&lt; point.y &lt;&lt; ")";
   return out;
}
 
<span class="color-comment">// Overload &gt;&gt; stream extraction operator</span>
istream &amp; operator&gt;&gt;(istream &amp; in, Point &amp; point) {
   cout &lt;&lt; "Enter x and y coord: ";
   in &gt;&gt; point.x &gt;&gt; point.y;
   return in;
}
 
<span class="color-comment">// Overload int + Point. Return a new point</span>
const Point operator+(int value, const Point &amp; rhs) {
   return rhs + value;  <span class="color-comment">// use member function defined above</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h5 class=""><span class="font-code">TestPoint.cpp</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td class="">
<pre class="">#include &lt;iostream&gt;
#include "Point.h"
using namespace std;
 
int main() {
   Point p1(1, 2);
   cout &lt;&lt; p1 &lt;&lt; endl;  <span class="color-comment"> // (1,2)</span>
 
   Point p2(3,4);
   cout &lt;&lt; p1 + p2 &lt;&lt; endl;<span class="color-comment"> // (4,6)</span>
   cout &lt;&lt; p1 + 10 &lt;&lt; endl;<span class="color-comment"> // (11,12)</span>
   cout &lt;&lt; 20 + p1 &lt;&lt; endl;<span class="color-comment"> // (21,22)</span>
   cout &lt;&lt; 10 + p1 + 20 + p1 &lt;&lt; endl;<span class="color-comment"> // (32,34)</span>
 
   p1 += p2;
   cout &lt;&lt; p1 &lt;&lt; endl;<span class="color-comment"> // (4,6)</span>
   p1 += 3;
   cout &lt;&lt; p1 &lt;&lt; endl;<span class="color-comment"> // (7,9)</span>
 
   Point p3; <span class="color-comment"> // (0,0)</span>
   cout &lt;&lt; p3++ &lt;&lt; endl;<span class="color-comment"> // (0,0)</span>
   cout &lt;&lt; p3 &lt;&lt; endl;  <span class="color-comment"> // (1,1)</span>
   cout &lt;&lt; ++p3 &lt;&lt; endl;<span class="color-comment"> // (2,2)</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h3 class="">7.&nbsp;&nbsp;Implicit Conversion via Single-argument Constructor &amp; Keyword "<span class="font-code">explicit</span>"<a id="zz-7." class="" style=""></a></h3>

<p class="">In C++, a <em class="">single-argument</em> constructor can be used to implicitly convert a value to an object. For example,</p>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td class="">
<pre class="">#include &lt;iostream&gt;
using namespace std;
 
class Counter {
private:
   int count;
public:
   <span class="color-new">Counter(int c = 0)</span> : count(c) { }
         <span class="color-comment">// A single-argument Constructor which takes an int
         // It can be used to implicitly convert an int to a Counter object</span>
   int getCount() const { return count; }   <span class="color-comment"> // Getter</span>
   void setCount(int c) { count = c; }<span class="color-comment"> // Setter</span>
};
 
int main() {
   <span class="color-new">Counter c1</span>;<span class="color-comment"> // Declare an instance and invoke default constructor</span>
   cout &lt;&lt; c1.getCount() &lt;&lt; endl; <span class="color-comment"> // 0</span>
 
   <span class="color-new">c1 = 9</span>;
    <span class="color-comment"> // Implicit conversion</span>
    <span class="color-comment"> // Invoke single-argument constructor Counter(9) to construct a temporary object.</span>
    <span class="color-comment"> // Then copy into c1 via memberwise assignment.</span>
   cout &lt;&lt; c1.getCount() &lt;&lt; endl; <span class="color-comment"> // 9</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="">This implicit conversion can be confusing. C++ introduces a keyword "<code class="">explicit</code>" to disable implicit conversion. Nonetheless, you can still perform explicit conversion via type cast operator. For example,</p>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td class="">
<pre class="">#include &lt;iostream&gt;
using namespace std;
 
class Counter {
private:
   int count;
public:
   <span class="color-new">explicit</span> Counter(int c = 0) : count(c) { }
     <span class="color-comment"> // Single-argument Constructor</span>
     <span class="color-comment"> // Use keyword "explicit" to disable implicit automatic conversion in assignment</span>
   int getCount() const { return count; }   <span class="color-comment"> // Getter</span>
   void setCount(int c) { count = c; }<span class="color-comment"> // Setter</span>
};
 
int main() {
   Counter c1;<span class="color-comment"> // Declare an instance and invoke default constructor</span>
   cout &lt;&lt; c1.getCount() &lt;&lt; endl; <span class="color-comment"> // 0</span>
 
<span class="color-comment">//</span> <span class="color-new">Counter c2 = 9;</span>
    <span class="color-comment"> // error: conversion from 'int' to non-scalar type 'Counter' requested
</span> 
   <span class="color-new">c1 = (Counter)9;</span> <span class="color-comment"> // Explicit conversion via type casting operator</span>
   cout &lt;&lt; c1.getCount() &lt;&lt; endl; <span class="color-comment"> // 9</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h3 class="">8.&nbsp;&nbsp;Example: The <span class="font-code">MyComplex</span> Class<a id="zz-8." class="" style=""></a></h3>

<p class="">The <code class="">MyComplex</code> class is simplified from the C++ STL's <code class="">complex</code> template class. I strongly recommend that you study the source code of <code class="">complex</code> (in the <code class="">complex</code> header) - you can download the source code for GNU GCC.</p>
<h5 class=""><span class="font-code">MyComplex.h</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 * The MyComplex class header (MyComplex.h)
 * Follow, modified and simplified from GNU GCC complex template class
 */</span>
#ifndef MY_COMPLEX_H
#define MY_COMPLEX_H
 
#include &lt;iostream&gt;
 
class MyComplex {
private:
   double real, imag;
 
public:
   explicit MyComplex (double real = 0, double imag = 0);<span class="color-comment"> // Constructor</span>
   MyComplex &amp; operator+= (const MyComplex &amp; rhs);<span class="color-comment"> // c1 += c2</span>
   MyComplex &amp; operator+= (double real);          <span class="color-comment"> // c += double</span>
   MyComplex &amp; operator++ ();                     <span class="color-comment"> // ++c</span>
   const MyComplex operator++ (int dummy);        <span class="color-comment"> // c++</span>
   bool operator== (const MyComplex &amp; rhs) const;  <span class="color-comment"> // c1 == c2</span>
   bool operator!= (const MyComplex &amp; rhs) const;  <span class="color-comment"> // c1 != c2</span>
 
  <span class="color-comment"> // friends</span>
   friend std::ostream &amp; operator&lt;&lt; (std::ostream &amp; out, const MyComplex &amp; c);<span class="color-comment"> // out &lt;&lt; c</span>
   friend std::istream &amp; operator&gt;&gt; (std::istream &amp; in, MyComplex &amp; c);       <span class="color-comment"> // in &gt;&gt; c</span>
   friend const MyComplex operator+ (const MyComplex &amp; lhs, const MyComplex &amp; rhs);<span class="color-comment"> // c1 + c2</span>
   friend const MyComplex operator+ (double real, const MyComplex &amp; rhs); <span class="color-comment"> // double + c</span>
   friend const MyComplex operator+ (const MyComplex &amp; lhs, double real); <span class="color-comment"> // c + double</span>
};
 
#endif
 </pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">I prefer to list the <code class="">private</code> section before the <code class="">public</code> section in the class declaration to have a quick look at the internal of the class for ease of understanding.</li>
<li class="">I named the <code class="">private</code> data members <code class="">real</code> and <code class="">imag</code>, that potentially crash with the function parameters. I resolves the crashes via <code class="">this-&gt;</code> pointer if needed. Some people suggest to name <code class="">private</code> data members with a trailing underscore (e.g., <code class="">real_</code>, <code class="">imag_</code>) to distinguish from the function parameters. As private members are not expose to the users, strange names are acceptable. The C++ compiler uses leading underscore(s) to name its variables internally (<code class="">_xxx</code> for data members, <code class="">__xxx</code> for local variables).</li>

<li class="">The constructor is declared <code class="">explicit</code>. This is because a single-argument constructor can be used for implicit conversion, in this case, from <code class="">double</code> to <code class="">MyComplex</code>, e.g.,
<pre class="color-example"><span class="color-comment">// Without explicit</span>
MyComplex c = 5.5;  <span class="color-comment">// Same as MyComplex c = (MyComplex)5.5;</span></pre>
The keyword <code class="">explicit</code> disables implicit conversion.
<pre class="color-example"><span class="color-comment">// With explicit</span>
MyComplex c = 5.5;
   <span class="color-comment">// error: conversion from 'double' to non-scalar type 'MyComplex' requested</span>
MyComplex c = (MyComplex)5.5;   <span class="color-comment">// Okay</span></pre>
Avoid implicit conversion, as it is hard to track and maintain.</li>

<li class="">The constructor sets the default value for <code class=""><code class="" style=""></code>real</code> and <code class="">imag</code> to 0.</li>
<li class="">We overload the stream insertion operator <code class="">&lt;&lt;</code> to print a <code class="">MyComplex</code> object on a <code class="">ostream</code> (e.g., <code class="">cout &lt;&lt; c</code>). We use a non-member friend function (instead of member function) as the left operand (<code class="">cout</code>) is not a <code class="">MyComplex</code> object. We declare it as friend of the <code class="">MyComplex</code> class to allow direct access of the private data members. The function return a reference of the invoking <code class="">ostream</code> object to support cascading operation, e.g. <code class="">cout &lt;&lt; c &lt;&lt; endl;</code>.</li>
<li class="">We overload the prefix increment operator (e.g., <code class="">++c</code>) and postfix increment operator (e.g., c++) as member functions. They increases the real part by 1.0. Since both prefix and postfix operators are unary, a dummy <code class="">int</code> argument is assigned to postfix <code class="">operator++()</code> to distinguish it from prefix <code class="">operator++()</code>. The prefix operator returns a reference to this object, but the postfix returns a value. We shall explain this in the implementation.</li>
<li class="">We overload the plus operator <code class="">+</code> to perform addition of two <code class="">MyComplex</code> objects, a <code class="">MyComplex</code> object and a <code class="">double</code>. Again, we use non-member friend function as the left operand may not be a <code class="">MyComplex</code> object. The <code class="">+</code> shall return a new object, with no change to its operands.</li>
<li class="">As we overload the <code class="">+</code> operator, we also have to overload <code class="">+=</code> operator.</li>
<li class="">The function's reference/pointer parameters will be declared <code class="">const</code>, if we do not wish to modify the original copy. On the other hand, we omit <code class="">const</code> declaration for built-in types (e.g., double) in the class declaration as they are passed by value - the original copy can never be changed.</li>
<li class="">We declare the return values of <code class="">+</code> operator as <code class="">const</code>, so that they cannot be used as <em class="">lvalue</em>. It is to prevent meaningless usages such as <code class="">(c1+c2) = c3</code> (most likely misspelling <code class="">(c1 + c2) == c3</code>).</li>
<li class="">We also declare the return value of <code class="">++</code> as <code class="">const</code>. This is to prevent <code class="">c++++</code>, which could be interpreted as <code class="">(c++)++</code>. However, as <code class="">C++</code> return by value a temporary object (instead of the original object), the subsequent <code class="">++</code> works on the temporary object and yields incorrect output. But <code class="">++++c</code> is acceptable as <code class="">++c</code> returns this object by reference.</li>
</ul>

<h5 class=""><span class="font-code">MyComplex.cpp</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* The MyComplex class implementation (MyComplex.cpp) */</span>
#include "MyComplex.h"
 
<span class="color-comment">// Constructor</span>
MyComplex::MyComplex (double r, double i) : real(r), imag(i) { }
 
<span class="color-comment">// Overloading += operator for c1 += c2</span>
MyComplex &amp; MyComplex::operator+= (const MyComplex &amp; rhs) {
   real += rhs.real;
   imag += rhs.imag;
   return *this;
}
 
<span class="color-comment">// Overloading += operator for c1 += double (of real)</span>
MyComplex &amp; MyComplex::operator+= (double value) {
   real += value;
   return *this;
}
 
<span class="color-comment">// Overload prefix increment operator ++c (real part)</span>
MyComplex &amp; MyComplex::operator++ () {
  ++real;  <span class="color-comment"> // increment real part only</span>
  return *this;
}
 
<span class="color-comment">// Overload postfix increment operator c++ (real part)</span>
const MyComplex MyComplex::operator++ (int dummy) {
   MyComplex saved(*this);
   ++real; <span class="color-comment"> // increment real part only</span>
   return saved;
}
 
<span class="color-comment">// Overload comparison operator c1 == c2</span>
bool MyComplex::operator== (const MyComplex &amp; rhs) const {
   return (real == rhs.real &amp;&amp; imag == rhs.imag);
}
 
<span class="color-comment">// Overload comparison operator c1 != c2</span>
bool MyComplex::operator!= (const MyComplex &amp; rhs) const {
   return !(*this == rhs);
}
 
<span class="color-comment">// Overload stream insertion operator out &lt;&lt; c (friend)</span>
std::ostream &amp; operator&lt;&lt; (std::ostream &amp; out, const MyComplex &amp; c) {
   out &lt;&lt; '(' &lt;&lt; c.real &lt;&lt; ',' &lt;&lt; c.imag &lt;&lt; ')';
   return out;
}
 
<span class="color-comment">// Overload stream extraction operator in &gt;&gt; c (friend)</span>
std::istream &amp; operator&gt;&gt; (std::istream &amp; in, MyComplex &amp; c) {
   double inReal, inImag;
   char inChar;
   bool validInput = false;
  <span class="color-comment"> // Input shall be in the format "(real,imag)"</span>
   in &gt;&gt; inChar;
   if (inChar == '(') {
      in &gt;&gt; inReal &gt;&gt; inChar;
      if (inChar == ',') {
         in &gt;&gt; inImag &gt;&gt; inChar;
         if (inChar == ')') {
            c = MyComplex(inReal, inImag);
            validInput = true;
         }
      }
   }
   if (!validInput) in.setstate(std::ios_base::failbit);
   return in;
}
 
<span class="color-comment">// Overloading + operator for c1 + c2</span>
const MyComplex operator+ (const MyComplex &amp; lhs, const MyComplex &amp; rhs) {
   MyComplex result(lhs);
   result += rhs; <span class="color-comment"> // uses overload +=</span>
   return result;
  <span class="color-comment"> // OR return MyComplex(lhs.real + rhs.real, lhs.imag + rhs.imag);</span>
}
 
<span class="color-comment">// Overloading + operator for c + double</span>
const MyComplex operator+ (const MyComplex &amp; lhs, double value) {
   MyComplex result(lhs);
   result += value; <span class="color-comment"> // uses overload +=</span>
   return result;
}
 
<span class="color-comment">// Overloading + operator for double + c</span>
const MyComplex operator+ (double value, const MyComplex &amp; rhs) {
   return rhs + value;  <span class="color-comment"> // swap and use above function</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">The prefix <code class="">++</code> increments the real part, and returns this object by reference. The postfix <code class="">++</code> saves this object, increments the real part, and returns the saved object by value. Postfix operation is clearly less efficient than prefix operation!</li>

<li class="">The <code class="">+</code> operators use the <code class="">+=</code> operator (for academic purpose).</li>

<li class="">The friend functions is allow to access the private data members.</li>
<li class="">The overloaded stream insertion operator <code class="">&lt;&lt;</code> outputs "<code class="">(real,imag)</code>".</li>
<li class="">The overloaded stream extraction operator <code class="">&gt;&gt;</code> inputs "<code class="">(real,imag)</code>". It sets the <code class="">failbit</code> of the <code class="">istream</code> object if the input is not valid.</li>
</ul>

<h5 class=""><span class="font-code">TestMyComplex.cpp</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* Test Driver for MyComplex class (TestMyComplex.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include "MyComplex.h"
 
int main() {
   std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);
 
   MyComplex c1(3.1, 4.2);
   std::cout &lt;&lt; c1 &lt;&lt; std::endl; <span class="color-comment"> // (3.10,4.20)</span>
   MyComplex c2(3.1);
   std::cout &lt;&lt; c2 &lt;&lt; std::endl; <span class="color-comment"> // (3.10,0.00)</span>
 
   MyComplex c3 = c1 + c2;
   std::cout &lt;&lt; c3 &lt;&lt; std::endl; <span class="color-comment"> // (6.20,4.20)</span>
   c3 = c1 + 2.1;
   std::cout &lt;&lt; c3 &lt;&lt; std::endl; <span class="color-comment"> // (5.20,4.20)</span>
   c3 = 2.2 + c1;
   std::cout &lt;&lt; c3 &lt;&lt; std::endl; <span class="color-comment"> // (5.30,4.20)</span>
 
   c3 += c1;
   std::cout &lt;&lt; c3 &lt;&lt; std::endl; <span class="color-comment"> // (8.40,8.40)</span>
   c3 += 2.3;
   std::cout &lt;&lt; c3 &lt;&lt; std::endl; <span class="color-comment"> // (10.70,8.40)</span>
 
   std::cout &lt;&lt; ++c3 &lt;&lt; std::endl;<span class="color-comment"> // (11.70,8.40)</span>
   std::cout &lt;&lt; c3++ &lt;&lt; std::endl;<span class="color-comment"> // (11.70,8.40)</span>
   std::cout &lt;&lt; c3   &lt;&lt; std::endl;<span class="color-comment"> // (12.70,8.40)</span>
 
<span class="color-comment">// c1+c2 = c3; <span class="color-comment"> // error: c1+c2 returns a const</span></span>
<span class="color-comment">// c1++++;     <span class="color-comment"> // error: c1++ returns a const</span></span>
 
<span class="color-comment">// MyComplex c4 = 5.5; <span class="color-comment"> // error: implicit conversion disabled</span></span>
   MyComplex c4 = (MyComplex)5.5; <span class="color-comment"> // explicit type casting allowed</span>
   std::cout &lt;&lt; c4 &lt;&lt; std::endl;<span class="color-comment"> // (5.50,0.00)</span>
 
   MyComplex c5;
   std::cout &lt;&lt; "Enter a complex number in (real,imag): ";
   std::cin &gt;&gt; c5;
   if (std::cin.good()) {  <span class="color-comment">// if no error</span>
      std::cout &lt;&lt; c5 &lt;&lt; std::endl;
   } else {
      std::cerr &lt;&lt; "Invalid input" &lt;&lt; std::endl;
   }
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h3 class="">9.&nbsp;&nbsp;Dynamic Memory Allocation in Object<a id="zz-9." class="" style=""></a></h3>

<p class="">If you dynamically allocate memory in the constructor, you need to provide your own destructor, copy constructor and assignment operator to manage the dynamically allocated memory. The defaults provided by the C++ compiler do not work for dynamic memory.</p>

<h4 class="">9.1&nbsp;&nbsp;Example: <span class="font-code">MyDynamicArray</span><a id="zz-9.1" class="" style=""></a></h4>

<h5 class=""><span class="font-code">MyDynamicArray.h</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 * The MyDynamicArray class header (MyDynamicArray.h)
 * A dynamic array of double elements
 */</span>
#ifndef MY_DYNAMIC_ARRAY_H
#define MY_DYNAMIC_ARRAY_H
 
#include &lt;iostream&gt;
 
class MyDynamicArray {
private:
   int size_;  <span class="color-comment"> // size of array</span>
   double * ptr; <span class="color-comment"> // pointer to the elements</span>
 
public:
   explicit MyDynamicArray (int n = 8);        <span class="color-comment"> // Default constructor</span>
   explicit MyDynamicArray (const MyDynamicArray &amp; a);<span class="color-comment"> // Copy constructor</span>
   MyDynamicArray (const double a[], int n);   <span class="color-comment"> // Construct from double[]</span>
   ~MyDynamicArray();                          <span class="color-comment"> // Destructor</span>
 
   const MyDynamicArray &amp; operator= (const MyDynamicArray &amp; rhs);<span class="color-comment"> // Assignment a1 = a2</span>
   bool operator== (const MyDynamicArray &amp; rhs) const;    <span class="color-comment"> // a1 == a2</span>
   bool operator!= (const MyDynamicArray &amp; rhs) const;    <span class="color-comment"> // a1 != a2</span>
 
   double operator[] (int index) const; <span class="color-comment"> // a[i]</span>
   double &amp; operator[] (int index);     <span class="color-comment"> // a[i] = x</span>
 
   int size() const { return size_; }   <span class="color-comment"> // return size of array</span>
 
  <span class="color-comment"> // friends</span>
   friend std::ostream &amp; operator&lt;&lt; (std::ostream &amp; out, const MyDynamicArray &amp; a);<span class="color-comment"> // out &lt;&lt; a</span>
   friend std::istream &amp; operator&gt;&gt; (std::istream &amp; in, MyDynamicArray &amp; a);       <span class="color-comment"> // in &gt;&gt; a</span>
};
 
#endif</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">In C++, the you cannot use the same name for a data member and a member function. As I would like to have a public function called <code class="">size()</code>, which is consistent with the C++ STL, I named the data member <code class="">size_</code> with a trailing underscore, following C++'s best practices. Take note that leading underscore(s) are used by C++ compiler for its internal variables (e.g., <code class="">_xxx</code> for data members and <code class="">__xxx</code> for local variables).</li>
<li class="">As we will be dynamically allocating memory in the constructor, we provide our own version of destructor, copy constructor and assignment operator to manage the dynamically allocated memory. The defaults provided by the C++ compiler do not work on dynamic memory.</li>
<li class="">We provide 3 constructors: a default constructor with an optional size, a copy constructor to construct an instance by copying another instance, and a construct to construct an instance by copying from a regular array.</li>
<li class="">We provide 2 version of indexing operators: one for read operation (e.g., <code class="">a[i]</code>) and another capable of write operation (e.g., <code class="">a[i] = x</code>). The read version is declared as a <code class="">const</code> member function; whereas the write version return a reference to the element, which can be used as <em class="">lvalue</em> for assignment.</li>

</ul>

<h5 class=""><span class="font-code">MyDynamicArray.cpp</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* The MyDynamicArray class implementation (MyDynamicArray.cpp) */</span>
#include &lt;stdexcept&gt;
#include "MyDynamicArray.h"
 
<span class="color-comment">// Default constructor</span>
MyDynamicArray::MyDynamicArray (int n) {
   if (n &lt;= 0) {
      throw std::invalid_argument("error: size must be greater then zero");
   }
 
  <span class="color-comment"> // Dynamic allocate memory for n elements</span>
   size_ = n;
   ptr = new double[size_];
   for (int i = 0; i &lt; size_; ++i) {
      ptr[i] = 0.0; <span class="color-comment"> // init all elements to zero</span>
   }
}
 
<span class="color-comment">// Override the copy constructor to handle dynamic memory</span>
MyDynamicArray::MyDynamicArray (const MyDynamicArray &amp; a) {
  <span class="color-comment"> // Dynamic allocate memory for a.size_ elements and copy</span>
   size_ = a.size_;
   ptr = new double[size_];
   for (int i = 0; i &lt; size_; ++i) {
      ptr[i] = a.ptr[i]; <span class="color-comment"> // copy each element</span>
   }
}
 
<span class="color-comment">// Construct via a built-in double[]</span>
MyDynamicArray::MyDynamicArray (const double a[], int n) {
  <span class="color-comment"> // Dynamic allocate memory for a.size_ elements and copy</span>
   size_ = n;
   ptr = new double[size_];
   for (int i = 0; i &lt; size_; ++i) {
      ptr[i] = a[i]; <span class="color-comment"> // copy each element</span>
   }
}
 
<span class="color-comment">// Override the default destructor to handle dynamic memory</span>
MyDynamicArray::~MyDynamicArray() {
   delete[] ptr; <span class="color-comment"> // free dynamically allocated memory</span>
}
 
<span class="color-comment">// Override the default assignment operator to handle dynamic memory</span>
const MyDynamicArray &amp; MyDynamicArray::operator= (const MyDynamicArray &amp; rhs) {
   if (this != &amp;rhs) { <span class="color-comment"> // no self assignment</span>
      if (size_ != rhs.size_) {
        <span class="color-comment"> // reallocate memory for the array</span>
         delete [] ptr;
         size_ = rhs.size_;
         ptr = new double[size_];
      }
     <span class="color-comment"> // Copy elements</span>
      for (int i = 0; i &lt; size_; ++i) {
         ptr[i] = rhs.ptr[i];
      }
   }
   return *this;
}
 
<span class="color-comment">// Overload comparison operator a1 == a2</span>
bool MyDynamicArray::operator== (const MyDynamicArray &amp; rhs) const {
   if (size_ != rhs.size_) return false;
 
   for (int i = 0; i &lt; size_; ++i) {
      if (ptr[i] != rhs.ptr[i]) return false;
   }
   return true;
}
 
<span class="color-comment">// Overload comparison operator a1 != a2</span>
bool MyDynamicArray::operator!= (const MyDynamicArray &amp; rhs) const {
   return !(*this == rhs);
}
 
<span class="color-comment">// Indexing operator - Read</span>
double MyDynamicArray::operator[] (int index) const {
   if (index &lt; 0 || index &gt;= size_) {
      throw std::out_of_range("error: index out of range");
   }
   return ptr[index];
}
 
<span class="color-comment">// Indexing operator - Writable a[i] = x</span>
double &amp; MyDynamicArray::operator[] (int index) {
   if (index &lt; 0 || index &gt;= size_) {
      throw std::out_of_range("error: index out of range");
   }
   return ptr[index];
}
 
<span class="color-comment">// Overload stream insertion operator out &lt;&lt; a (as friend)</span>
std::ostream &amp; operator&lt;&lt; (std::ostream &amp; out, const MyDynamicArray &amp; a) {
   for (int i = 0; i &lt; a.size_; ++i) {
      out &lt;&lt; a.ptr[i] &lt;&lt; ' ';
   }
   return out;
}
 
<span class="color-comment">// Overload stream extraction operator in &gt;&gt; a (as friend)</span>
std::istream &amp; operator&gt;&gt; (std::istream &amp; in, MyDynamicArray &amp; a) {
   for (int i = 0; i &lt; a.size_; ++i) {
      in &gt;&gt; a.ptr[i];
   }
   return in;
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">Constructor: [TODO]</li>
<li class="">Copy Constructor:</li>
<li class="">Assignment Operator:</li>
<li class="">Indexing Operator:</li>

</ul>

<h5 class=""><span class="font-code">TestMyDynamicArray.cpp</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* Test Driver for MyDynamicArray class (TestMyDynamicArray.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include "MyDynamicArray.h"
 
int main() {
   std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) &lt;&lt; std::boolalpha;
 
   MyDynamicArray a1(5);
   std::cout &lt;&lt; a1 &lt;&lt; std::endl; <span class="color-comment"> // 0.0 0.0 0.0 0.0 0.0</span>
   std::cout &lt;&lt; a1.size() &lt;&lt; std::endl; <span class="color-comment"> // 5</span>
 
   double d[3] = {1.1, 2.2, 3.3};
   MyDynamicArray a2(d, 3);
   std::cout &lt;&lt; a2 &lt;&lt; std::endl;<span class="color-comment"> // 1.1 2.2 3.3</span>
 
   MyDynamicArray a3(a2);  <span class="color-comment"> // Copy constructor</span>
   std::cout &lt;&lt; a3 &lt;&lt; std::endl;<span class="color-comment"> // 1.1 2.2 3.3</span>
 
   a1[2] = 8.8;
   std::cout &lt;&lt; a1[2] &lt;&lt; std::endl; <span class="color-comment"> // 8.8</span>
<span class="color-comment">// std::cout &lt;&lt; a1[22] &lt;&lt; std::endl;<span class="color-comment"> // error: out_of_range</span></span>
 
   a3 = a1;
   std::cout &lt;&lt; a3 &lt;&lt; std::endl;<span class="color-comment"> // 0.0 0.0 8.8 0.0 0.0</span>
 
   std::cout &lt;&lt; (a1 == a3) &lt;&lt; std::endl; <span class="color-comment"> // true</span>
   std::cout &lt;&lt; (a1 == a2) &lt;&lt; std::endl; <span class="color-comment"> // false</span>
 
   const int SIZE = 3;
   MyDynamicArray a4(SIZE);
   std::cout &lt;&lt; "Enter " &lt;&lt; SIZE &lt;&lt; " elements: ";
   std::cin &gt;&gt; a4;
   if (std::cin.good()) {
      std::cout &lt;&lt; a4 &lt;&lt; std::endl;
   } else {
      std::cerr &lt;&lt; "Invalid input" &lt;&lt; std::endl;
   }
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>


<a class="references" href="http://www.ntu.edu.sg/home/ehchua/programming/howto/References.html#cpp">Link to "C++ References &amp; Resources"</a>

</div> <!-- End the content-main division -->

<div id="content-footer" class="">
<p class="">Latest version tested: Cygwin/MinGW GCC 4.6.2<br class="">
Last modified: May, 2013</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p class="">Feedback, comments, corrections, and errata can be sent to Chua Hock-Chuan (ehchua@ntu.edu.sg) &nbsp;&nbsp;|&nbsp;&nbsp; <a href="http://www.ntu.edu.sg/home/ehchua/programming/index.html" class="">HOME</a></p></div>

</div>  <!-- End the wrap-outer division -->



<div class="selection_bubble_root" style=""></div></body></html>