<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--
 Archive processed by SingleFile 
 url: http://www.ntu.edu.sg/home/ehchua/programming/cpp/cp9_String.html 
 saved date: Mon Aug 25 2014 15:17:53 GMT+0900 (Tokyo Standard Time) 
--><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>C++ Libraries, String and Standard Template Library</title>
<style rel="stylesheet" type="text/css" data-href="http://www.ntu.edu.sg/home/ehchua/programming/css/programming_notes_v1.css">/* 
 * Universal selector - clear all the margin and padding to get consistent layout for Firefox and IE 
 */
* { 
	margin: 0;
	padding: 0;
}

/* 
 * Set default style for all the tags.
 * Apply to the main content division as well.
 */
body {
	background-color: rgb(202, 251, 237);
	color: #000;
	font-family: "Segoe UI", Segoe, Calibri, "Ubuntu", Tahoma, Arial, Helvetica, Verdana, sans-serif;
	font-size: 14px;
	text-align: justify;
	line-height: 1.5;
}

/*
 * "wrap-outer" wraps header, wrap-inner and footer
 */
#wrap-outer {
	margin: 20px 20px 20px 20px;
	padding: 0;
	
}
/*
 * "wrap-inner" wraps content-header, content-main and content-footer
 */
#wrap-inner {
	background-color: #fff;
	margin: 0;
	border: 1px solid #ddd;
	padding: 25px 15px;
	box-shadow: 5px 5px 0 #ddd;
}
#content-header {
	margin: 0;
	padding: 50px 0 10px 0;
}

#content-main {
	margin: 0;
	padding: 30px 0 20px 0;
}
#content-footer {
	font-family: "Century Gothic", "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	font-size: 13px;
	text-align: right;
	color: rgb(192, 80, 77);
/*	color: rgb(11, 83, 149); */
	margin: 30px 0 0 0;
    padding: 0;
	border-top: 4px solid rgb(12, 155, 116);
}
/*
 *  The main "header" & "footer" divisions
 */
.header-footer {
	font-family: "Century Gothic", "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	color: rgb(192, 80, 77);
/*	color: rgb(11, 83, 149); */
	font-size: 13px;
	text-align: right;
	margin: 10px 0 5px 0;
	padding: 5px 4px;
}
.header-footer a {
	color: rgb(192, 80, 77);
	text-decoration: underline;
}
.header-footer a:focus, .header-footer a:hover {  /* change color and remove underline */
	text-decoration: none;
 	color: rgb(11, 83, 149);
/*	color: rgb(192, 80, 77); */
}

h1, h2, h3, h4, h5, h6 {  /* main title and sub-title */
	font-family: "Century Gothic", "Trebuchet MS", "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	margin: 0;
	color: rgb(10, 132, 100);
	letter-spacing: 1px;
	line-height: 1.2;
	text-align:left;
}
h1 {
	font-size: 40px;
	font-weight: 400;
	padding: 0.2em 0;
}
h2 {
	font-size: 36px;
	font-weight: 400;
	padding: 0.2em 0;
}
h3 {
	font-size: 22px;
	border-bottom: thin solid rgb(12, 155, 116);
	padding: 1.5em 0 0.3em 0;
}
h4 {
	font-family: "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	font-size: 18px;
	padding: 1.3em 0 0.2em 0;
	border-bottom: thin dotted rgb(12, 155, 116);
}
h5, h6 {
	font-family: "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	font-size: 15px;
	color: #444;
	padding: 1.2em 0 0 0;  /* top right bottom left */
	letter-spacing: 1px;
}
.line-heading {
	color: #444;
	font-size: 15px;
	font-weight: bold;
	letter-spacing: 1px;
	padding: 0.2em 0;
}
.line-heading-code-new {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	color: #E31B23;
	font-size: 15px;
    font-weight: normal;
/*	letter-spacing: 0.5px; */
}
p {
	margin-top: 0.6em;
	margin-bottom: 0.4em;
}
pre {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	font-size: 13px;
	margin: 5px 0 8px 0;
	border: solid 2px #f8f8f8;  /* slight 3D shape */
	padding: 5px 10px;
	line-height: 135%;
}
code {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
}

ul {   /* first level ul */
	margin: 0.3em 0 0.2em 1.8em;
	padding: 0;
/*	list-style-type: square;  */
	list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAQMAAABBztZFAAAABlBMVEUAAwBjjJzG2b5OAAAAAXRSTlMAQObYZgAAABBJREFUCNdjYMAG7FARAwMADXkBNzRuJgIAAAAASUVORK5CYII=);
}
ul ul li {   /* 2nd level ul */
	list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAANAQMAAABb8jbLAAAABlBMVEX///8AUow5QSOjAAAAAXRSTlMAQObYZgAAABNJREFUCB1jYEABBQw/wLCAgQEAGpIDyT0IVcsAAAAASUVORK5CYII=);
/*
	list-style-type: disc;
	list-style-image: none; */
}
ul ul u1 li {   /* 3rd level ul */
	list-style-type: circle;
	list-style-image: none;
}
ol {   /* first level ol */
/*    list-style-position:inside; */
/*    display: table  */
    list-style-type: decimal;
	margin: 0.3em 0 0.2em 2.5em;
	padding: 0;
}
ol ol li {   /* 2nd level ol */
	list-style-type: lower-alpha;
}
ol ol o1 li {  /* 3rd level ol */
	list-style-type: lower-roman;
}

li {
	margin: 0.4em 0;
}

.float-left-ol-ul {
	overflow:hidden;
}

/* li after a left-float image */
.float-left-li {
   position: relative; left: 20px;
   margin-right: 20px;
}

a {
	color: rgb(11, 83, 149);
	text-decoration: none;
}
a:hover, a:focus {
	color: rgb(192, 80, 77);
	text-decoration: underline;
}

a.references {
	display: block;
	width: 30em;
	font-size: 18px;
	font-weight: bold;
	margin: 4em 0 0 0;
}

p.references {
	font-size: 18px;
	font-weight: bold;
	margin: 4em 0 0 0;
}

/*
 * General classes
 */
.center-block {
	margin: 10px auto;  /* auto margin-left and margin-right to center the table */
}
.text-center {	
    text-align: center; 
}
.text-right {	
    text-align: right; 
}
.underline {
	text-decoration: underline;
}
.font-code {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
}
.font-code-text {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	font-size: 14px;
}
.font-code-smaller {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	font-size: 13px;
}
.font-normal {
	font-family: "Segoe UI", Segoe, Calibri, "Ubuntu", Tahoma, Arial, Helvetica, Verdana, sans-serif;
}
.pre {
    white-space: pre;	
}
/* color control mainly for <pre>, <div>, <span> */
.color-example {
	background-color: rgb(215, 236, 211);  /* darker */
}
.color-example-light {
	background-color: rgb(236, 246, 234);  /* lighter */
}
.color-syntax, .color-command {
	background-color: rgb(204, 238, 241);  /* darker */
}
.color-explanation {
	background-color: #eee;   /* grey */
}
/* Character level control for code listing */
.color-comment {
	color: #009900;  /* green */
}
.color-new {
	color: #E31B23;  /* dark red to highlight new terms */
}
.color-error {
	color: #ff0099;  /* bright red */
/*	font-weight:bold; */
}
.color-plain {
	background-color: #fff;
}
.color-highlight {
	background-color: #ff0;
}
.color-highlight-new {
    background-color: #FFC;  /* lighter */
}

.output {  /* Output of program or DOS session */
    background-color: rgb(236, 246, 234);  /* lighter */
	border: solid 2px #f8f8f8;   /* slight 3D shape */
	padding: 4px 8px;
}
.side-note {
	margin-top: 15px;
    margin-left: 40px;
	padding: 3px 8px; 
	background-color: #e7e7e7;
}


/*
 * for positioning images 
 */
img.image-center {      /* center horizontally an image */
	display: block;
	margin: 10px auto;
}
img.image-border {
    border: #ddd thin solid;
}
img.image-float-left {
	float: left;
	margin: 8px 15px 15px 0;
    border: #ddd thin solid;
}
img.image-float-right {
	float: right;
	margin: 8px 0 15px 15px;
    border: #ddd thin solid;
}
.float-clear {
   clear: both;	
}
/*
 *  Table - for tablulating data with alternate row colors or different column colors
 */
table.table-zebra, table.table-program {
	border-collapse: collapse;
	border: 0;
	margin: 0 auto; /* center */
	padding: 0;
    width: 100%;
	/* Default setting for all cells in this table, inherited */
    background-color: rgb(231, 240, 248);  /* lighter */
	text-align: left;
	vertical-align: top;
}
table.table-zebra th {  /* header cells */
	color: #ffffff;     /* white text on dark background */
	background-color: rgb(0, 157, 217);
	margin: 0;
	border: 2px solid white;
	padding: 4px 10px;
	font-size: 15px;
	letter-spacing: 1px;
	text-align: center;
}
table.table-zebra td {  /* data cells */
    margin: 0;
	border: 2px solid white;
	padding: 2px 8px;
	/* color, font, text inherited from table */
	vertical-align: top;
}

table.table-program th {  /* header cells */
	color: #ffffff;     /* white text on dark background */
	background-color: rgb(0, 157, 217);
	margin: 0;
	border: 2px solid white;
	padding: 4px 10px;
	font-size: 15px;
	letter-spacing: 1px;
	text-align: center;
}
table.table-program td {  /* data cells */
    margin: 0;
	border: 0;
	padding: 0;
	/* color, font, text inherited from table */
}

table.table-program td pre {
	margin: 0;
	border: solid 2px #f8f8f8;   /* slight 3D shape */
	padding: 5px 10px;
}

table.table-program td pre.text-right {
	text-align: right;
}

/* Setting the color for row (2 colors) or column (3 colors) */
/* can only set the background, border, width of <col>, NOT font, text, color */
/* for table-zebra */
table .col-desc {       /* same as default color */
    background-color: rgb(231, 240, 248);  /* lighter */
}
table .col-code, table .tr-alt {
	background-color: rgb(203, 223, 241);  /* darker */
}
table .col-example {
    background-color: #eee;  /* grey */
}

/* for table-program */
table .col-line-number {
	width: 40px;
    background-color: rgb(225, 233, 207);
}
table .col-program {
    background-color: rgb(240, 244, 233);
}

/*
 * For the "Table of Content" generated by JavaScript
 * in <div id="toc">
 */
#wrap-toc {
    display: block;
	background: none repeat scroll 0 0 rgb(231, 246, 239);
	float: right;
	width: 230px;
	z-index: 100;
	line-height: 1.5;
	margin: 0 0 0 15px;
	padding: 5px 8px 10px 8px;
	text-align: left;
	white-space: nowrap;
/*	min-height: 180px;  */
}
#wrap-toc h5 {
   letter-spacing: 1px;
   margin: 0;
   text-transform: uppercase;
	color: #444;
	padding: 0.5em 0;
}
a#show-toc {
	color: rgb(192, 80, 77);
	text-decoration: none;
   letter-spacing: 1px;
}
#toc {
	overflow: auto;
}
#toc a.toc-H3 {
    margin-left: 0px;
	font-size: 15px;
}
#toc a.toc-H4 {
    margin-left: 20px;
	font-size: 14px;
}
#toc a.toc-H5 {
    margin-left: 40px;
	font-size: 14px;
}
</style>

<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAADy8O0APrMnACEdGADb2tkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMzMzMzMzMzMyIiIiIiIiIzIiIiIiIiIjMgIiIgAAAiMyACIiAAACIzIgAiIiIiIjMiIAIiIiIiMyIiACIiIiIzIiACIiIiIjMiACISEiESMyACIhISEiIzICIiERISIjMiIiISEhIiMyIiIhISIRIzIiIiIiIiIjMzMzMzMzMzMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" type="image/x-icon"></head>

<body class="">

<div id="wrap-outer" class="">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p class="">yet another insignificant programming notes... &nbsp;&nbsp;| &nbsp;&nbsp;<a href="http://www.ntu.edu.sg/home/ehchua/programming/index.html" class="">HOME</a></p></div>

<div id="wrap-inner" class="">

<div id="wrap-toc" class="">
<h5 class="">TABLE OF CONTENTS <a id="show-toc" href="#show-toc" class="">(HIDE)</a></h5>
<div id="toc" class=""><a class="toc-H3" href="#zz-1.">1.&nbsp;&nbsp;Characters</a><br class=""><a class="toc-H4" href="#zz-1.1">1.1&nbsp;&nbsp;Header <span class="font-code">&lt;cctype&gt;</span> - Character Type Library</a><br class=""><a class="toc-H3" href="#zz-2.">2.&nbsp;&nbsp;Strings: The C-String and the <span class="font-code">string</span> class</a><br class=""><a class="toc-H4" href="#zz-2.1">2.1&nbsp;&nbsp;C-String Literals</a><br class=""><a class="toc-H4" href="#zz-2.2">2.2&nbsp;&nbsp;C-String Headers  and Functions</a><br class=""><a class="toc-H4" href="#zz-2.3">2.3&nbsp;&nbsp;The C++'s <span class="font-code">string</span> class</a><br class=""><a class="toc-H4" href="#zz-2.4">2.4&nbsp;&nbsp;The C-String Input Methods</a><br class=""><a class="toc-H4" href="#zz-2.5">2.5&nbsp;&nbsp;The <span class="font-code">string</span> Class Input Methods</a><br class=""><a class="toc-H4" href="#zz-2.6">2.6&nbsp;&nbsp;<span class="font-code">basic_string</span> Template Class</a><br class=""><a class="toc-H3" href="#zz-3.">3.&nbsp;&nbsp;Unicode Characters and Strings</a><br class=""><br class=""></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header" class="">
<h1 class="">C++ Programming Language</h1>
<h2 class="">Characters and Strings</h2>
</div>

<div id="content-main" class="">

<h3 class="">1.&nbsp;&nbsp;Characters<a id="zz-1." class="" style=""></a></h3>

<h4 class="">1.1&nbsp;&nbsp;Header <span class="font-code">&lt;cctype&gt;</span> - Character Type Library<a id="zz-1.1" class="" style=""></a></h4>

<p class="">The <code class="">&lt;cctype&gt;</code> character type header (ported from C' <code class="">&lt;ctype.h&gt;</code>), contains the following character handling functions.</p>

<table class="table-program">
<tbody class=""><tr class="">
<th class="">FUNCTION</th>
<th class="">EXAMPLE</th>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax">int <strong class="">isalpha</strong> (int ch);
  <span class="color-comment">Return 1 if ch is alphabetic; and 0 otherwise</span>
int <strong class="">isdigit</strong> (int ch);
  <span class="color-comment">Return 1 if ch is a digit [0-9]; and 0 otherwise</span>
int <strong class="">isalnum</strong> (int ch);
  <span class="color-comment">Return 1 if ch is an alphabet or digit; and 0 otherwise</span>
int <strong class="">isxdigit </strong>(int ch);
  <span class="color-comment">Return 1 if ch is a hexadecimal digit [0-9A-Fa-f]; and 0 otherwise</span>
</pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 
 
 
 
 
 
 </pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax">int <strong class="">isupper</strong> (int ch);
  <span class="color-comment">Return 1 if ch is in uppercase; and 0 otherwise</span>
int <strong class="">islower</strong> (int ch);
  <span class="color-comment">Return 1 if ch is in lowercase; and 0 otherwise</span></pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 
 
</pre></td>
</tr>

<tr class="">
<td class=""><pre class="color-syntax">int <strong class="">toupper</strong> (int ch);
  <span class="color-comment">Return the uppercase of ch</span>
int <strong class="">tolower</strong> (int ch);
  <span class="color-comment">Return the lowercase of ch</span></pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 
 
</pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax">int <strong class="">isspace</strong> (int ch);
  <span class="color-comment">Return 1 if ch is a white space (blank ' ', carriage return '\r',
  newline '\n', tab '\t', form feed '\f', vertical tab '\v') and 0 otherwise</span>
int <strong class="">ispunct</strong> (int ch)  <span class="color-comment">punctuation character?</span>
int <strong class="">iscntrl</strong> (int ch)  <span class="color-comment">control character?</span>
int <strong class="">isprint</strong> (int ch)  <span class="color-comment">printable character?</span>
int <strong class="">isgraph</strong> (int ch)  <span class="color-comment">graphical representation?</span></pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 
 
 
 
 
 </pre></td>
</tr>
</tbody></table>

<p class="">All these functions treat a <code class="">char</code> as a signed <code class="">int</code>.</p>


<h3 class="">2.&nbsp;&nbsp;Strings: The C-String and the <span class="font-code">string</span> class<a id="zz-2." class="" style=""></a></h3>

<p class="">Recall that C++ supports two types of strings:</p>

<ol class="">
<li class="">The C-style string (or C-String) in header <code class="">cstring</code> (ported over from C's <code class="">string.h</code>), which represents a string as a <code class="">char</code> array terminated by a null character <code class="">'\0'</code> (or 0) (null-terminated char array).</li>
<li class="">The new C++ <code class="">string</code> <em class="">class</em> in header <code class="">string</code>. <code class="">string</code> is a regular class, with <em class="">public interface</em> defined in the constructors and public member functions.</li>
</ol>

<h4 class="">2.1&nbsp;&nbsp;C-String Literals<a id="zz-2.1" class="" style=""></a></h4>

<p class="">A string literal such as <code class="">"hello"</code> is treated as "an array of <code class=""><em class="">n</em></code> <code class=""><span class="underline">const</span></code> <code class="">char</code>", terminated with the null <code class="">'\0'</code> character (equivalent to 0), where <code class=""><em class="">n</em></code> is the length of the array including the terminating null character.</p>

<pre class="color-example">int main() {
   char * str1 = "hello";
         <span class="color-error"> // warning: deprecated conversion from string constant to 'char*'</span>
   char * str2 = <strong class="">const_cast&lt;char *&gt;</strong>("hello");   <span class="color-comment">// remove the "const"</span>
 
   const char * str3 = "hello";
<span class="color-error">// *(str3 + 1) = 'a';  // error: assignment of read-only location '*(str3 + 1u)'</span>
 
   char str4[] = "hello";
   str4[1] = 'a';
 
   const char str5[] = "hello";
<span class="color-error">//  str5[1] = 'a';   // error: assignment of read-only location 'str5[1]'</span>
}</pre>

<p class="">Take note that you cannot modify the content pointed to by <code class="">const char *</code>.</p>

<h4 class="">2.2&nbsp;&nbsp;C-String Headers  and Functions<a id="zz-2.2" class="" style=""></a></h4>

<p class="">C-string (null-terminated <code class="">char</code> array) can be declared as <code class="">char*</code> or <code class="">char[]</code>. This is because C treats an array name as a pointer to the first element of the array. Unlike regular arrays, there is no need to pass the length of C-string into function, as the function can deduce the length from the terminating null character.</p>

<h5 class="">C-String Functions in <span class="font-code">&lt;cstring&gt;</span> header</h5>

<p class="">The <code class="">&lt;cstring&gt;</code> header (ported from C's <code class="">string.h</code>) contains these commonly-used functions to operate on C-strings.</p>

<table class="table-program">
<tbody class=""><tr class="">
<th class="">FUNCTION</th>
<th class="">EXAMPLE</th>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax">size_t <strong class="">strlen</strong> (const char * cstr)
  <span class="color-comment">Return the length of cstr, excluding terminating null character '\0'.
  size_t is typically typedef of unsigned int.</span></pre></td>
<td class="">
<pre class="color-example">char * msg = "Hello";
cout &lt;&lt; strlen(msg);  <span class="color-comment">// length of string</span>
 </pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax"><span class="color-comment">// Copying</span>
char * <strong class="">strcpy</strong> (char * dest, const char * src)
  <span class="color-comment">Copy src into dest, return dest</span>
char * <strong class="">strncpy</strong> (char * dest, const char * src, size_t n)
  <span class="color-comment">Copy at most n characters from src into dest, return dest</span></pre></td>
<td class="" style="">
<pre class="color-example" style="">&nbsp;

 
 
 
 </pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax"><span class="color-comment">// Comparison</span>
int <strong class="">strcmp</strong> (const char * cstr1, const char * cstr2)
  <span class="color-comment">Compare cstr1 and cstr2. Return 0 if cstr1 is equal to cstr1,
  less than zero (usually -1) if cstr1 is less than cstr2,
  more than zero (usually 1) if cstr1 is more than cstr2.</span>
int <strong class="">strncmp</strong> (const char * cstr1, const char * cstr2, size_t n)
  <span class="color-comment">Compare up to n characters.</span></pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 
 
 
 
 
 </pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax"><span class="color-comment">// Concatenation</span>
char * <strong class="">strcat</strong> (char * dest, const char * src)
  <span class="color-comment">Append src to dest, return src.</span>
char * <strong class="">strncat</strong> (char * dest, const char * src, size_t n)
  <span class="color-comment">Append at most n characters from src into dest, return src.</span></pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 
 
 
 </pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax"><span class="color-comment">// Searching</span>
char * <strong class="">strchr</strong>  (char * cstr, int ch);<span class="color-comment">
  Return a pointer to the first occurrence of character</span>
char * <strong class="">strrchr</strong> (char * cstr, int ch);
  <span class="color-comment">Return a pointer to the last occurrence of character</span>
char * <strong class="">strstr</strong>  (char * cstr1, char * cstr2);
  <span class="color-comment">Return a pointer to the first occurrence of cstr2 in cstr1</span>
size_t <strong class="">strspn</strong> (const char * cstr, const char * accept)
  <span class="color-comment">Return the length (span) of the initial portion of cstr
  which consists of only characters in accept
</span>char * <strong class="">strpbrk</strong> (char * cstr, const char * accept)
  <span class="color-comment">Similar to strspn, but string pointer break returns a pointer
  to the first occurrence in cstr of any char in accept</span>
size_t <strong class="">strcspn</strong> (const char * cstr, const char * reject)
  <span class="color-comment">Complement of strspn. Return the length of the initial
  portion of cstr, which does not have char in reject</span></pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax"><span class="color-comment">// Tokenizing</span>
char * <strong class="">strtok</strong> (char * cstr, const char * delim)
  <span class="color-comment">Tokenize cstr with delim as the delimiters</span></pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 
 </pre></td>
</tr>
</tbody></table>

<p class="">[TODO] example</p>

<h5 class="">C-String Functions in <span class="font-code">&lt;cstdlib&gt;</span> header</h5>

<p class="">The <code class="">&lt;cstdlib&gt;</code> header (ported from C's <code class="">&lt;stdlib.h&gt;</code>) contains functions to convert C-strings to fundamental types.</p>

<table class="table-program">
<tbody class=""><tr class="">
<th class="">FUNCTION</th>
<th class="">EXAMPLE</th>
</tr>

<tr class="">
<td class=""><pre class="color-syntax">int <strong class="">atoi</strong> (char * cstr)
  <span class="color-comment">Parse C-string cstr into an int</span>
double <strong class="">atof</strong> (char * cstr)
  <span class="color-comment">Parse C-string cstr into a double</span>
long <strong class="">atol</strong> (char * cstr)
  <span class="color-comment">Parse C-string cstr into a long int</span>
long long <strong class="">atoll</strong> (char * cstr)
  <span class="color-comment">Parse C-string cstr into a long long int</span></pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 
 
 
 
 
 
 </pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax">double <strong class="">strtod</strong> (const char * cstr, char** endptr)
  <span class="color-comment">Parse C-string cstr into a double. If endptr is not a null pointer,
  set the endptr to the first character after the number</span>
float <strong class="">strtof</strong> (const char * cstr, char** endptr)
long <strong class="">strtol</strong> (const char * cstr, char** endptr)
long double <strong class="">strtold</strong> (const char * cstr, char** endptr)
long long <strong class="">strtoll</strong> (const char * cstr, char** endptr)
unsigned long long <strong class="">strtoull</strong> (const char * cstr, char** endptr)</pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 
 
 
 
 
 
 </pre></td>
</tr>
</tbody></table>

<p class="">[TODO] example</p>

<h5 class="">C-String Input/Output Functions in <span class="font-code">&lt;iostream&gt;</span> Header</h5>
<p class="">The <code class="">&lt;iostream&gt;</code> supports these functions for c-string input and output:</p>

<table class="table-program">
  <tbody class=""><tr class="">
    <th class="">FUNCTION</th>
    <th class="">EXAMPLE</th>
  </tr>
  <tr class="">
    <td class="">
<pre class="color-syntax"><strong class="">cin &gt;&gt; var</strong>
   Read a word (delimiter by space)</pre></td>
    <td class="">
<pre class="color-example">char *msg;
cin &gt;&gt; msg;</pre>
</td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax"><strong class="">cin.getline(char * cstr, unsigned int n)</strong>
<strong class="">cin.getline(char * cstr, unsigned int n, char delim)</strong>
  Read n-1 characters ('\0' appended) or till delimiter is reached. 
  The delimiter character is not stored.</pre>
</td>

<td class="">
<pre class="color-example">char msg[256];
cin.getline(msg, 256);
cin.getline(msg, 256, '\n');
  </pre>
</td>
</tr>
<tr class="">
  <td class="">
<pre class="color-syntax"><strong class="">int cin.get()</strong>: Return the next character, casted as an int.</pre></td>
<td class="" style="">
<pre class="color-example" style="">&nbsp;
</pre>
</td>
</tr>
<tr class="">
  <td class="">
<pre class="color-syntax"><strong class="">cin.peek()</strong>: return the next character (casted as an int), 
   but not removing it from the input stream.</pre>
</td>
<td class="" style="">
<pre class="color-example" style="">&nbsp;
</pre>
</td>
</tr>
<tr class="">
  <td class="">
<pre class="color-syntax"><strong class="">cin.ignore(unsigned int n = 1, int delim = EOF)</strong>:
  Remove n-1 characters from the input stream, or until delimiter is reached.</pre>
  </td>
<td class="">
<pre class="color-example">cin.ignore(256, ' ');   <span class="color-comment">// Skip next word</span>
cin.ignore(1000, '\n'); <span class="color-comment">// Flush input buffer</span></pre>
</td>
</tr>
</tbody></table>


<h5 class="">Converting C-string to Uppercase/Lowercase</h5>

<p class="">You probably have to write your own function using <code class="">cctype</code>'s <code class="">toupper()</code> and <code class="">tolower()</code>, which converts individual character. For example,</p>

<pre class="color-example">inline void strtoupper(char* str) {
   while (*str) {
      *str = toupper(*str);
      ++str;
   }
}</pre>

<h4 class="">2.3&nbsp;&nbsp;The C++'s <span class="font-code">string</span> class<a id="zz-2.3" class="" style=""></a></h4>

<p class="">The <code class="">string</code> class, in header <code class="">&lt;string&gt;</code> and under namespace <code class="">std</code> (i.e., <code class="">std::string</code>), models character sequences. The <code class="">string</code> class is an instantiation of the <code class="">basic_string&lt;T&gt;</code>  template class that uses <code class="">char</code> type with a <code class="">typedef</code>.</p>

<pre class="color-syntax">typedef basic_string&lt;char&gt; <strong class="">string</strong>;
typedef basic_string&lt;wchar_t&gt; <strong class="">wstring</strong>;</pre>

<h5 class=""><span class="font-code">string</span> Class Constructors</h5>

<pre class="color-syntax"><strong class="">string</strong> ();
   <span class="color-comment">// (1) Default constructor: construct an empty string of length 0.</span>
<strong class="">string</strong> (const string &amp; str);
   <span class="color-comment">// (2) Copy constructor: construct by copying str (by value)</span>
<strong class="">string</strong> (const string &amp; str, size_t pos, size_t len = npos);
   <span class="color-comment">// (3) Substring constructor: copy the substring starting at pos, of the len.
   // size_t is usually typedef to unsigned int
   // npos is a static constant in string (i.e., string::npos),
   //   which holds the maximum value of size_t.</span>
<strong class="">string</strong> (const char * cstr);
   <span class="color-comment">// (4) C-string: construct by copying the C-string.</span>
<strong class="">string</strong> (const char * cstr, size_t len);
   <span class="color-comment">// (5) C-string buffer: construct by copying the cstr for len</span>
<strong class="">string</strong> (size_t len, char c);
   <span class="color-comment">// (6) Fill Constructor: fill len with char c</span>
template &lt;class Iterator&gt;
<strong class="">string</strong> (Iterator first, Iterator last);
   <span class="color-comment">// (7) Iterator: copy the char in [first, last)</span>
<strong class="">string</strong> (initializer_list&lt;char&gt; initList);
   <span class="color-comment">// (C++11)(8) Initializer list</span>
<strong class="">string</strong> (string &amp;&amp; str) noexcept;
   <span class="color-comment">// (C++11)(9) Move Constructor</span></pre>

<p class="">Example,</p>

<pre class="color-example">string str1("apple");
string str2 = orange;
   <span class="color-comment">// '=' is not an assignment, but an implicit call to string's
   // constructor str2("orange");</span></pre>

<p class="">You cannot construct a <code class="">string</code> from <code class="">char</code>, <code class="">int</code> or <code class="">double</code>.</p>

<h5 class="">Example: <span class="font-code">string</span> Constructor</h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56</pre>
</td>
<td class="">
<pre class="">#include &lt;iostream&gt;
#include &lt;string&gt;  <span class="color-comment"> // C++ string class</span>
#include &lt;cstring&gt; <span class="color-comment"> // C-string</span>
using namespace std;
 
int main() {
   char cstr[] = "hello world!"; <span class="color-comment"> // C-string literal</span>
 
   <span class="color-new">string s1</span>;                  <span class="color-comment"> // (1) Default constructor</span>
   cout &lt;&lt; s1.length() &lt;&lt; endl;<span class="color-comment"> // 0</span>
   cout &lt;&lt; s1.size() &lt;&lt; endl;  <span class="color-comment"> // 0 - length() and size() are synonyms</span>
 
   <span class="color-new">string s4(cstr)</span>;   <span class="color-comment"> // (4) C-string</span>
   s4[1] = 'E';       <span class="color-comment"> // [] does not perform index bound check</span>
   cout &lt;&lt; s4 &lt;&lt; endl;<span class="color-comment"> // "hEllo world!"</span>
 
   <span class="color-new">string s2(s4)</span>;      <span class="color-comment"> // (2) Copy constructor</span>
   s2.at(0) = 'H';     <span class="color-comment"> // at() does index-bound check</span>
                       <span class="color-comment"> // at() can be used on RHS</span>
   cout &lt;&lt; s2 &lt;&lt; endl; <span class="color-comment"> // "HEllo world!"</span>
   cout &lt;&lt; s4 &lt;&lt; endl; <span class="color-comment"> // no change - copy by value</span>
 
   <span class="color-new">string s3a(s4, 2)</span>;  <span class="color-comment"> // (3) Substring</span>
   cout &lt;&lt; s3a &lt;&lt; endl;<span class="color-comment"> // "llo world!"</span>
   s3a += " again";    <span class="color-comment"> // Append</span>
   cout &lt;&lt; s3a &lt;&lt; endl;<span class="color-comment"> // "llo world! again"</span>
 
   <span class="color-new">string s3b(s3a, 4, 3)</span>;<span class="color-comment"> // (3) Substring</span>
   cout &lt;&lt; s3b &lt;&lt; endl;  <span class="color-comment"> // "wor"</span>
 
   <span class="color-new">string s5a(cstr, strlen(cstr))</span>; <span class="color-comment"> // (5) C-string buffer</span>
   cout &lt;&lt; s5a &lt;&lt; endl; <span class="color-comment"> // "hello world!"</span>
   string s5b(cstr, 15);            <span class="color-comment"> // (5) C-string buffer</span>
   cout &lt;&lt; s5b &lt;&lt; endl; <span class="color-comment"> // "hello world! ??"</span>
       <span class="color-comment"> // If len &gt; length of cstr, garbage copied</span>
 
   <span class="color-new">string s6(5, '$')</span>;   <span class="color-comment"> // (6) Fill constructor</span>
   cout &lt;&lt; s6 &lt;&lt; endl;  <span class="color-comment"> // "$$$$$"</span>
 
   <span class="color-new">string s7a(cstr, cstr + 4)</span>; <span class="color-comment"> // (7) Iterator</span>
   cout &lt;&lt; s7a &lt;&lt; endl; <span class="color-comment"> // "hell"</span>
       <span class="color-comment"> // cstr1 is char*. Instantiate type parameter Iterator to char*</span>
 
<span class="color-comment">//</span>   <span class="color-new">string s7b(s4, s4 + 2)</span>;
       <span class="color-comment"> // error: no match for 'operator+' in 's4 + 2'</span>
       <span class="color-comment"> // s4 is a string object, not char*</span>
 
   <span class="color-new">string s7c(&amp;s4[0], &amp;s4[2])</span>;  <span class="color-comment"> // (7) Iterator</span>
       <span class="color-comment"> // &amp;s4[0] and &amp;s4[2] are char*</span>
   cout &lt;&lt; s7c &lt;&lt; endl;         <span class="color-comment"> // "hE"</span>
 
   <span class="color-new">string s7d(s4.begin(), s4.end())</span>;
       <span class="color-comment"> // begin() returns an iterator pointing to the first character</span>
       <span class="color-comment"> // end() returns an iterator pointing to past-the-end character</span>
   cout &lt;&lt; s7d &lt;&lt; endl;  <span class="color-comment"> // "hEllo world!"</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h5 class="">Example: C++11 <span class="font-code">string</span> Constructor</h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13</pre>
</td>
<td class="">
<pre class="">#include &lt;iostream&gt;
#include &lt;string&gt;  <span class="color-comment"> // C++ string class</span>
using namespace std;
 
int main() {
  <span class="color-comment"> // To compile with option -std=c++0x</span>
   <span class="color-new">string str1 = {'a', 'p', 'p', 'l', 'e'}</span>;   <span class="color-comment"> // (8) C++11 Initializer List</span>
   cout &lt;&lt; str1 &lt;&lt; endl;                      <span class="color-comment"> // "apple"</span>
   <span class="color-new">string str2 {'o', 'r', 'a', 'n', 'g', 'e'}</span>;<span class="color-comment"> // (8) C++11 Initializer List ("=" optional)</span>
   cout &lt;&lt; str2 &lt;&lt; endl;                      <span class="color-comment"> // "orange"</span>
        <span class="color-comment"> // Using C-string literal is more convenient</span>
        <span class="color-comment"> // Included in string class to make initializer list syntax universal</span>
}</pre>
</td>
</tr>
</tbody>
</table>

<h5 class=""><span class="font-code">string</span> Class Overloaded Operators</h5>

<p class="">Most of the string class operators are overloaded to handle <code class="">string</code> objects, as well as C-string and literals.</p>

<pre class="color-syntax"><span class="color-comment">// Member functions - First operand must be a string object</span>
<strong class="">=</strong>      <span class="color-comment">// assignment</span>
<strong class="">[]</strong>     <span class="color-comment">// character at index - no index range check</span>
<strong class="">+=</strong>     <span class="color-comment">// append</span>

<span class="color-comment">// Friends (non-member functions) - First operand could be a non-string</span>
<strong class="">+</strong>                      <span class="color-comment">// Concatenate two strings (one of them could be C-string or literal),
                       //   return a new string object (by value)</span>
<strong class="">==</strong>, <strong class="">!=</strong>, <strong class="">&lt;</strong>, <strong class="">&lt;=</strong>, <strong class="">&gt;</strong>, <strong class="">&gt;=</strong>   <span class="color-comment">// Relational (comparison) operators.
                       // Compare two strings (one of them could be C-string or literal)
                       //   based on the machine collating sequence</span>
<strong class="">&gt;&gt;</strong>                     <span class="color-comment">// Stream extraction (input)</span>
<strong class="">&lt;&lt;</strong>                     <span class="color-comment">// Stream insertion (output)</span></pre>

<h5 class="">Public Functions</h5>

<p class="">Most of the string class functions are overloaded to handle <code class="">string</code> objects, as well as C-string and literals.</p>

<pre class="color-syntax"><span class="color-comment">// Capacity</span>
size_t <strong class="">size</strong> () const;    <span class="color-comment">// Return the size of the string</span>
size_t <strong class="">length</strong> () const;  <span class="color-comment">// same as above
                         // length() was from earlier version, size() added for compatibility with STL</span>
bool <strong class="">empty</strong> () const;     <span class="color-comment">// Return true for empty string</span>
void <strong class="">clear</strong> ();           <span class="color-comment">// Clear to empty string</span>
void <strong class="">resize</strong> (size_t n, char pad = '\0');  <span class="color-comment">// resize the string to length n,
                                          // discard trailing characters, or insert pad char</span>

<strong class="">string::npos</strong>             <span class="color-comment">// static variable for the maximum possible characters in string,
                         // typically max of size_t (unsigned int)</span>
size_t <strong class="">max_size</strong> () const;    <span class="color-comment">// Return the maximum size of string object</span>
size_t <strong class="">capacity</strong> () const;    <span class="color-comment">// Storage (in terms of characters) currently allocated</span>
void <strong class="">reserve</strong> (size_t n = 0); <span class="color-comment">// Request for minimum of this capacity</span>
void <strong class="">shrink_to_fit</strong> ();       <span class="color-comment">// (C++11) Request to reduce the capacity</span></pre>

<p class="">Unlike C-string, which uses a fixed-size array, the <code class="">string</code> class handles the memory allocated implicitly. In other words, you can append more characters without worrying about exceeding the size. C++ implementation may allocate an initial block which is larger than the actual string length to allow the content to grow, and allocate more block when the current block is filled. You can use function <code class="">capacity()</code> to check the current allocation, and <code class="">reserve()</code> to request for a minimum allocation.</p>

<p class="">Example:</p>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre>
</td>
<td class="">
<pre class="">#include &lt;iostream&gt;
#include &lt;string&gt;  <span class="color-comment"> // C++ string class</span>
using namespace std;
 
int main() {
   string strLarge("This is a very very very vary large string");
   string strSmall("Hi");
   string strEmpty;
 
   cout &lt;&lt; "size=" &lt;&lt; strLarge.size() &lt;&lt; " capacity=" &lt;&lt; strLarge.capacity() &lt;&lt; endl;
   cout &lt;&lt; "size=" &lt;&lt; strSmall.size() &lt;&lt; " capacity=" &lt;&lt; strSmall.capacity() &lt;&lt; endl;
   cout &lt;&lt; "size=" &lt;&lt; strEmpty.size() &lt;&lt; " capacity=" &lt;&lt; strEmpty.capacity() &lt;&lt; endl;
 
   cout &lt;&lt; "string::npos=" &lt;&lt; string::npos &lt;&lt; endl;
   cout &lt;&lt; "max_size=" &lt;&lt; strEmpty.max_size() &lt;&lt; endl;
 
   strSmall.reserve(100);
   cout &lt;&lt; "size=" &lt;&lt; strSmall.size() &lt;&lt; " capacity=" &lt;&lt; strSmall.capacity() &lt;&lt; endl;
 
   strLarge.resize(10);
   cout &lt;&lt; strLarge &lt;&lt; endl;
   cout &lt;&lt; "size=" &lt;&lt; strLarge.size() &lt;&lt; " capacity=" &lt;&lt; strLarge.capacity() &lt;&lt; endl;
   strSmall.resize(10, '-');
   cout &lt;&lt; strSmall &lt;&lt; endl;
   cout &lt;&lt; "size=" &lt;&lt; strSmall.size() &lt;&lt; " capacity=" &lt;&lt; strSmall.capacity() &lt;&lt; endl;
 
   strLarge.clear();
   cout &lt;&lt; "size=" &lt;&lt; strLarge.size() &lt;&lt; " capacity=" &lt;&lt; strLarge.capacity() &lt;&lt; endl;
   strLarge.shrink_to_fit();  <span class="color-comment"> // C++11</span>
   cout &lt;&lt; "size=" &lt;&lt; strLarge.size() &lt;&lt; " capacity=" &lt;&lt; strLarge.capacity() &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">size=42 capacity=42
size=2 capacity=2
size=0 capacity=0
string::npos=4294967295
max_size=1073741820
size=2 capacity=100
This is a
size=10 capacity=42
Hi--------
size=10 capacity=100
size=0 capacity=42
size=0 capacity=0</pre>

<pre class="color-syntax"><span class="color-comment">// C-string</span>
c_str;</pre>

<p class="">Some functions, such as <code class="">ofstream</code>'s <code class="">open()</code> which opens a file, accept only C-string. You can use <code class="">c_str</code> to get a C-string from an <code class="">string</code> object.</p>

<pre class="color-syntax"><span class="color-comment">// Element Access</span>
char &amp; <strong class="">operator[]</strong> (size_t pos);  <span class="color-comment">// Return char at pos, no index range check</span>
char &amp; <strong class="">at</strong> (size_t pos);          <span class="color-comment">// Return char at pos, with index range check</span>
char &amp; <strong class="">front</strong> ();                 <span class="color-comment">// Return first char</span>
char &amp; <strong class="">back</strong> ();                  <span class="color-comment">// Return last char</span>
string <strong class="">substr</strong> (size_t pos = 0, size_t len = npos) const;  <span class="color-comment">// Return a substring</span>
 
<span class="color-comment">// Modifying</span>
append
insert
assign
erase
replace
swap
push_back
pop_back
compare

<span class="color-comment">// Searching</span>
size_t <strong class="">find</strong> (const string &amp; str, size_t pos = 0) const;
size_t <strong class="">find</strong> (const char * cstr, size_t pos = 0) const;
size_t <strong class="">find</strong> (const char * cstr, size_t pos, size_t n) const;
size_t <strong class="">find</strong> (char c, size_t pos = 0) const;
    <span class="color-comment">// Find the first occurrence of the string or char, starting from pos
    // Return the index or string::npos if not found</span>
<strong class="">rfind</strong>: last occurrence
<strong class="">find_first_of</strong>: first occurrence of ANY of the character in the string
<strong class="">find_last_of</strong>: last occurrence of ANY of the character in the string
<strong class="">find_first_not_of</strong>: first occurrence of NOT ANY of the character in the string
<strong class="">find_last_not_of</strong>: last occurrence of NOT ANY of the character in the string</pre>

<h5 class="">Example: <span class="font-code">string</span> objects and their operations</h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 * Guess a secret word (WordGuess.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;cctype&gt;
using namespace std;
 
const int NUM_WORDS = 18;
const string WORD_LIST[NUM_WORDS] = {
   "apple", "orange", "banana", "watermelon", "pear",
   "pineapple", "papaya", "mango", "grape", "strawberry",
   "lemon", "peach", "cherry", "apricot", "coconut",
   "honeydew", "apricot", "blueberry"};
 
int main() {
  <span class="color-comment"> // Seed the pseudo-random number generator</span>
   srand(time(0));
 
   bool over = false;  <span class="color-comment"> // gameover</span>
   do {
      string target = WORD_LIST[rand() % NUM_WORDS];<span class="color-comment"> // choose a word between 0 to NUM_WORDS-1</span>
      int target_length = target.length();
      string attempt(target_length, '-');           <span class="color-comment"> // init to all dashes</span>
      string badChars;                              <span class="color-comment"> // contains bad chars used</span>
      int trial = 1;                                <span class="color-comment"> // number of trials</span>
 
      cout &lt;&lt; "Guess the secret word" &lt;&lt; endl;
 
      while (attempt != target) {
         char letter;
         cout &lt;&lt; "Your guess so far: " &lt;&lt; attempt &lt;&lt; endl;
         cout &lt;&lt; "Trial " &lt;&lt; trial &lt;&lt; ": Guess a letter: ";
         cin &gt;&gt; letter;
 
        <span class="color-comment"> // Check if the letter has been used</span>
         if (badChars.find(letter) != string::npos
               || attempt.find(letter) != string::npos) {
            cout &lt;&lt; "You already use this letter. Try again.\n";
            continue;
         }
 
        <span class="color-comment"> // Check for good or bad letter</span>
         int pos = target.find(letter);
         if (pos == string::npos) {
            cout &lt;&lt; "Oh, bad guess!\n";
            badChars += letter;    <span class="color-comment"> // add to badChars string</span>
         } else {
            cout &lt;&lt; "Good guess!\n";
            attempt[pos] = letter;
           <span class="color-comment"> // Check if this letter appears again later</span>
            do {
               pos = target.find(letter, pos + 1);
               if (pos != string::npos) attempt[pos] = letter;
            } while (pos != string::npos);
         }
 
         ++trial;
      }
 
      cout &lt;&lt; "You got it in " &lt;&lt; trial &lt;&lt; " trials! The secret word is \""
           &lt;&lt; target &lt;&lt; "\"" &lt;&lt; endl;
 
      char playAgain;
      cout &lt;&lt; "Another game? &lt;y/n&gt; ";
      cin &gt;&gt; playAgain;
      if (playAgain != 'y' &amp;&amp; playAgain != 'Y') over = true;
   } while (!over);
 
   cout &lt;&lt; "Bye\n";
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>


<p class="">[TODO] More Example</p>

<h5 class="">Converting a <span class="font-code">string</span> to Uppercase/Lowercase</h5>
<p class="">Use the <code class="">transform()</code> function in <code class="">algorithm</code>.</p>
<pre class="color-example">#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;cctype&gt;
 
std::string str = "Hello World";
std::transform(str.begin(), str.end(), str.begin(), ::toupper);</pre>

<h4 class="">2.4&nbsp;&nbsp;The C-String Input Methods<a id="zz-2.4" class="" style=""></a></h4>

<p class="">C-string has three input methods: stream extraction operator (<code class="">&gt;&gt;</code>), <code class="">getline()</code> and <code class="">get()</code>. All 3 functions belong to the <code class="">istream</code> class.</p>

<h5 class=""><span class="font-code">istream</span>'s Overloaded Stream Extraction Operator (<span class="font-code">&gt;&gt;</span>)</h5>

<p class="">The stream extraction operator (<code class="">&gt;&gt;</code>) of <code class="">istream</code> class has the following prototype for C-strings:</p>

<pre class="color-syntax">istream &amp; <strong class="">operator&gt;&gt;</strong> (istream &amp; is, char * str);
 
<span class="color-comment">// Example usage:</span>
char str[80];
cin &gt;&gt; str;</pre>

<p class="">It extracts characters from the input stream and store into <code class="">str</code>, until either a whitespace (blank, tab, newline) is encountered or  <code class="">width-1</code> characters is read. A terminating null character is automatically inserted. The default <code class="">width</code> is 0, indicating unlimited. You can set the <code class="">width</code> via <code class="">cin &gt;&gt; setw(<em class="">n</em>)</code> (in header <code class="">&lt;iomanip&gt;</code>) or <code class="">cin.width(<em class="">n</em>)</code>. <code class="">setw()</code> is non-sticky and is only applicable to next input operation. It is reset to 0. The trailing whitespace is left in the input stream. The leading white spaces are ignored.</p>
<p class="">For example,</p>

<pre class="color-example">const int SIZE = 5;
char str[SIZE];    <span class="color-comment">// max strlen is SIZE - 1</span>

cout &lt;&lt; "Enter a word: ";
<span class="color-new">cin &gt;&gt; setw(SIZE) &gt;&gt; str</span>;   <span class="color-comment">// need &lt;iomanip&gt; header</span>
cout &lt;&lt; str &lt;&lt; endl;</pre>

<p class="">We set the <code class="">width</code> to the <code class="">SIZE</code> (=5) of the <code class="">char[]</code>. <code class="">cin &lt;&lt;</code> reads up to 4 characters or whitespace.</p>
<ul class="">
<li class="">If you enter <code class="">"12\n"</code>, <code class="">"12"</code> is read into <code class="">str</code>, and <code class="">"\n"</code> remains in the input buffer.</li>

<li class="">If you enter <code class="">"12345\n"</code>, <code class="">"1234"</code> is read into <code class="">str</code>, and <code class="">"5\n"</code> remains in the input buffer.</li>

<li class="">If you enter <code class="">"12 345\n"</code>, <code class="">"12"</code> is read into <code class="">str</code>, and <code class="">" 345\n"</code> remains in the input buffer.</li>
<li class="">The next <code class="">cin &gt;&gt;</code> discards the leading whitespaces and starts with the first non-whitespace character.</li>
<li class="">If <code class="">width</code> is not set properly and if the  input (including the terminating null character) exceeds the size of <code class="">char</code> array,  memory will be corrupted.</li>
<li class="">You may need to flush the input buffer (see below).</li>
</ul>

<h5 class=""><span class="font-code">istream::getline()</span></h5>

<p class="">The <code class="">getline()</code> function of the <code class="">istream</code> class has the following prototypes:</p>

<pre class="color-syntax">istream &amp; <strong class="">getline</strong> (char * str, int n);
istream &amp; <strong class="">getline</strong> (char * str, int n, char delim);
 
<span class="color-comment">// Example usage</span>
char str[80];
cin.getline(str, 80);      <span class="color-comment">// Read up to 79 chars or '\n'; discarding '\n'</span>
cin.getline(str, 80, ':'); <span class="color-comment">// Read up to 79 chars or ':'; discarding ':'</span></pre>

<p class=""><code class="">getline()</code> extracts characters from the input stream and stores in <code class="">str</code>, until either it reaches the  delimiter character (default of  <code class="">'\n'</code>), or <code class=""><em class="">n-1</em></code> character is written to <code class="">str</code>. A terminating null character is automatically inserted. The delimiter, if found, is extracted and discarded from input stream. You can use <code class="">cin.gcount()</code> to get the number of characters extracted (including <code class="">delim</code>). <code class="">getline()</code> reads all whitespace (including leading whitespaces which is ignore by <code class="">cin &gt;&gt;</code>).</p>
<p class="">If <code class="">n-1</code> character is read and the next character is not delimit, then the <code class="">failbit</code> (of the <code class="">istream</code>) is set. You can check the <code class="">failbit</code> via <code class="">bool</code> function <code class="">cin.fail()</code>. You need to invoke <code class="">cin.clear()</code> to clear the error bit. Otherwise, all subsequent <code class="">getline()</code> will fail and return <code class="">gcount()</code> of 0.</p>

<p class="">For example,</p>

<pre class="color-example">const int SIZE = 5;
char str[SIZE];    <span class="color-comment">// max strlen is SIZE - 1</span>
 
cout &lt;&lt; "Enter a line: ";
<span class="color-comment"><span class="color-new">cin.getline(str, SIZE);</span>     // Read a line (including whitespaces) until newline, discard newline</span>
cout &lt;&lt; "\"" &lt;&lt; str &lt;&lt; "\" length=" &lt;&lt; strlen(str) &lt;&lt; endl;
cout &lt;&lt; "Number of characters extracted: " &lt;&lt; cin.gcount() &lt;&lt; endl;
 
if (<span class="color-new">cin.fail()</span>) {
   cout &lt;&lt; "failbit is set!" &lt;&lt; endl;
   <span class="color-new">cin.clear()</span>;  <span class="color-comment"> // Clear all error bits. Otherwise, subsequent getline() fails</span>
}</pre>

<p class="">Again, we set <code class=""><em class="">n</em></code> to the <code class="">SIZE</code> (=5) of <code class="">char[]</code>. <code class="">getline()</code> reads up to 4 characters or <code class="">'\n'</code>.</p>
<ul class="">
<li class="">If you enter <code class="">"xxxx\n"</code>, where <code class="">xxxx</code> may include whitespaces, <code class="">"xxxx"</code> is read into <code class="">str</code>, and <code class="">"\n"</code> discarded from input buffer.</li>
<li class="">If you enter <code class="">"xxxxyyy\n"</code>, <code class="">"xxxx"</code> is read into str, <code class="">"yyy\n"</code> remains in input buffer. <code class="">failbit</code> is set. You need to clear the error bits before issuing another <code class="">getline()</code> call.</li>


</ul>


<h5 class=""><span class="font-code">istream::get()</span></h5>

<p class="">The <code class="">get()</code> function of the <code class="">istream</code> class has the following prototypes for C-string:</p>

<pre class="color-syntax"><span class="color-comment">// C-string</span>
istream &amp; <strong class="">get</strong> (char * str, int n);
istream &amp; <strong class="">get</strong> (char * str, int n, char delim);</pre>

<p class=""><code class="">get(str, n, delim)</code> is similar to <code class="">getline(str, n, delim)</code>, except that the <code class="">delim</code> character is not extracted and remains in the input stream.</p>

<h5 class="">Single-character Input</h5>

<p class="">The <code class="">get()</code> member function is more often used to read a single character, unformatted, including whitespaces and newlines. It has the following two versions:</p>
<pre class="color-syntax"><span class="color-comment">// Single character</span>
istream &amp; <strong class="">get</strong> (char &amp; c);  <span class="color-comment">// Read next character into the char reference and
                           //   return the istream for concatenated operations
                           //   It returns null pointer (converted to false) at end-of-file</span>
int <strong class="">get</strong> ();                <span class="color-comment">// Read next character and return an int
                           //   Return a special value EOF at end-of-file</span>

<span class="color-comment">// Examples</span>
char ch;
while (cin.get(ch) &amp;&amp; ch != '\') { ...... }  <span class="color-comment">// read all characters until newline</span>
  <span class="color-comment">// You cannot use cin &gt;&gt; ch, because it ignores the whitespace</span>
while (cin.get(ch)) { ...... }   <span class="color-comment">// read until end-of-file</span>

int ch;
while (ch = cin.get() != EOF) { ....... }  <span class="color-comment">// read until end-of-file</span></pre>

<p class="">When the end-of-file is encountered, <code class="">get(char &amp;)</code> returns a null pointer, which is converted to <code class="">false</code>. On the other hand, <code class="">get(void)</code> return a special value EOF (defined in <code class="">&lt;iostream&gt;</code>). <code class="">get(char &amp;)</code> has no room to represent any special symbol such as EOF!</p>

<p class="">In brief, there are 3 methods for reading single character, <code class="">cin &gt;&gt; char</code>, <code class="">get(char &amp;)</code> and <code class="">get(void)</code>. <code class="">cin &gt;&gt; char</code> skips whitespaces, <code class="">get(char &amp;)</code> reads a character by reference, while <code class="">get(void)</code> reads a character and return an <code class="">int</code>. <code class="">get(void)</code> is closely resembled the C's <code class="">getchar(void)</code> function (in <code class="">stdio.h</code>) and can be used to convert C programs into C++.</p>

<h5 class="">Flushing the <span class="font-code">cin</span> Buffer</h5>

<p class="">Use <code class="">cin.ignore()</code> as follows. You may need to issue an <code class="">cin.clear()</code> to clear the error bits first.</p>

<pre class="color-example"><span class="color-comment">// Ignore to the end-of-file</span>
cin.ignore(numeric_limits&lt;streamsize&gt;::max());  <span class="color-comment">// need header &lt;limits&gt;</span>
 
<span class="color-comment">// Ignore to the end-of-line</span>
cin.ignore(numeric_limits&lt;streamsize&gt;::max(), '\n');</pre>

<h5 class="">Others</h5>

<p class=""><code class="">istream::peek()</code>, <code class="">istream::unget()</code>, etc.</p>

<h4 class="">2.5&nbsp;&nbsp;The <span class="font-code">string</span> Class Input Methods<a id="zz-2.5" class="" style=""></a></h4>

<p class="">The <code class="">string</code> class has two input methods: stream extraction operator (<code class="">&gt;&gt;</code>) and <code class="">getline()</code>. Both methods are similar to C-string counterpart, but they are much simpler, as you don't need to worry about the limit of the <code class="">string</code>, compared with a fixed-size <code class="">char</code> array.</p>

<h5 class=""><span class="font-code">string</span>'s Stream Extraction Operator (<span class="font-code">&gt;&gt;</span>)</h5>

<p class="">The <code class="">string</code> class overloads the <code class="">&gt;&gt;</code> (stream extraction operator) via <em class="">friend</em> function such that it operates on <code class="">string</code> object like C-string:</p>

<pre class="color-syntax">istream &amp; <strong class="">operator&gt;&gt;</strong> (istream &amp; is, string &amp; str)
 
<span class="color-comment">// Example usage</span>
string str;
cin &gt;&gt; str;
  <span class="color-comment">// Compared with C-string, no need to set the width</span></pre>
 
<p class="">It extracts a string (word) from the input stream, delimited by whitespace (blank, tab or newline), and stores in <code class="">str<span class="color-comment" style=""></span></code>, overriding its previous value. The size of <code class="">str</code> is determined by the length of input.</p>

<h5 class=""><span class="font-code">string::getline()</span></h5>

<p class="">The <code class="">string</code> class also provides a <em class="">friend</em> function <code class="">getline()</code>:</p>

<pre class="color-syntax">istream &amp; <strong class="">getline</strong> (istream &amp; is, string &amp; str);
istream &amp; <strong class="">getline</strong> (istream &amp; is, string &amp; str, char delim);
 
<span class="color-comment">// Example usage</span>
string str;
getline(cin, str);       <span class="color-comment">// default delimiter of '\n'</span>
getline(cin, str, ':');
   <span class="color-comment">// Compared with C-string:
   // 1. No need to specify a limit
   // 2. NOT cin.getline() 
   //    C-string getline() is a member function of istream class
   //    string class' getline() is a non-member friend function</span></pre>

<p class="">It extracts characters from the input stream into <code class="">str</code> until the delimiter character is found (default of newline <code class="">'\n'</code>) or end-of-file is reached. The delimiter is extracted and discard from the input buffer, i.e., the next operation will begin after the delimiter. The size of <code class="">str</code> is determined by the length of input.</p>

<h5 class="">Notes</h5>

<ul class="">
<li class="">The maximum allowable size for a <code class="">string</code> object is defined by the constant <code class="">string::npos</code>, which is typically the maximum value of <code class="">unsigned int</code>.</li>
<li class="">If <code class="">getline()</code> is used to read from a file, and end-of-file is encountered, the <code class="">eofbit</code> of the input stream will be set. That is, <code class="">fail()</code> and <code class="">eof()</code> of the input stream will return <code class="">true</code>.</li>
<li class="">If the maximum allowable size of string is reached, or memory exhausted, the <code class="">failbit</code> of the input stream will be set. That is, <code class="">fail()</code> of the input stream will return <code class="">true</code>.</li>
<li class="">An input stream maintains its status in these bits: <code class="">goodbit</code> (<code class="">good()</code> function) indicates all is fine; <code class="">failbit</code> (<code class="">fail()</code> function) indicates input error; <code class="">badbit</code> (<code class="">bad()</code> function) indicates recognized failure such as hardware failure; <code class="">eofbit</code> (<code class="">eof()</code> function) indicates end-of-file detected.</li>
</ul>

<h4 class="">2.6&nbsp;&nbsp;<span class="font-code">basic_string</span> Template Class<a id="zz-2.6" class="" style=""></a></h4>

<p class="">The <code class="">string</code> class is an instantiation of the <code class="">basic_string</code> template class with parameterized type of <code class="">char</code>.</p>

<p class="">The declaration of <code class="">basic_string</code> is:</p>

<pre class="color-syntax">template &lt; class charT,
           class traits = char_traits&lt;charT&gt;,    // basic_string::traits_type
           class Alloc  = allocator&lt;charT&gt; &gt;     // basic_string::allocator_type
class <strong class="">basic_string</strong>;</pre>

<p class="">There are 4 instantiations for <code class="">basic_string</code> template class, with a <code class="">typedef</code>.</p>

<pre class="color-syntax">typedef basic_string&lt;<strong class="">char</strong>&gt; <strong class="">string</strong>;
typedef basic_string&lt;<strong class="">wchar_t</strong>&gt; <strong class="">wstring</strong>;
typedef basic_string&lt;<strong class="">char16_t</strong>&gt; <strong class="">u16string</strong>;  <span class="color-comment">// C++11</span>
typedef basic_string&lt;<strong class="">char32_t</strong>&gt; <strong class="">u32string</strong>;  <span class="color-comment">// C++11</span></pre>

<h3 class="">3.&nbsp;&nbsp;Unicode Characters and Strings<a id="zz-3." class="" style=""></a></h3>

<p class="">[TODO] Types: <code class="">wchar_t</code>, <code class="">char16_t</code>, <code class="">char32_t</code>.</p>
<p class="">[TODO] C's headers: <code class="">cuchar</code>, <code class="">wchar</code>, <code class="">cwctype</code>.</p>

<p class="">[TODO] C++ Classes: <code class="">wstring</code>, <code class="">u16string</code>, <code class="">u32string</code>.</p>


<a class="references" href="http://www.ntu.edu.sg/home/ehchua/programming/howto/References.html#cpp">Link to "C++ References &amp; Resources"</a>


</div> <!-- End the content-main division -->

<div id="content-footer" class="">
<p class="">Latest version tested: GCC 4.6.2<br class="">
Last modified: May, 2013</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p class="">Feedback, comments, corrections, and errata can be sent to Chua Hock-Chuan (ehchua@ntu.edu.sg) &nbsp;&nbsp;|&nbsp;&nbsp; <a href="http://www.ntu.edu.sg/home/ehchua/programming/index.html" class="">HOME</a></p></div>

</div>  <!-- End the wrap-outer division -->


<div class="selection_bubble_root" style=""></div></body></html>