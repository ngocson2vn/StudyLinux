<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><!--
 Archive processed by SingleFile 
 url: http://www.ntu.edu.sg/home/ehchua/programming/cpp/cp9_STL.html 
 saved date: Mon Aug 25 2014 15:18:04 GMT+0900 (Tokyo Standard Time) 
--><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>C++ Libraries, String and Standard Template Library</title>
<style rel="stylesheet" type="text/css" data-href="http://www.ntu.edu.sg/home/ehchua/programming/css/programming_notes_v1.css">/* 
 * Universal selector - clear all the margin and padding to get consistent layout for Firefox and IE 
 */
* { 
	margin: 0;
	padding: 0;
}

/* 
 * Set default style for all the tags.
 * Apply to the main content division as well.
 */
body {
	background-color: rgb(202, 251, 237);
	color: #000;
	font-family: "Segoe UI", Segoe, Calibri, "Ubuntu", Tahoma, Arial, Helvetica, Verdana, sans-serif;
	font-size: 14px;
	text-align: justify;
	line-height: 1.5;
}

/*
 * "wrap-outer" wraps header, wrap-inner and footer
 */
#wrap-outer {
	margin: 20px 20px 20px 20px;
	padding: 0;
	
}
/*
 * "wrap-inner" wraps content-header, content-main and content-footer
 */
#wrap-inner {
	background-color: #fff;
	margin: 0;
	border: 1px solid #ddd;
	padding: 25px 15px;
	box-shadow: 5px 5px 0 #ddd;
}
#content-header {
	margin: 0;
	padding: 50px 0 10px 0;
}

#content-main {
	margin: 0;
	padding: 30px 0 20px 0;
}
#content-footer {
	font-family: "Century Gothic", "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	font-size: 13px;
	text-align: right;
	color: rgb(192, 80, 77);
/*	color: rgb(11, 83, 149); */
	margin: 30px 0 0 0;
    padding: 0;
	border-top: 4px solid rgb(12, 155, 116);
}
/*
 *  The main "header" & "footer" divisions
 */
.header-footer {
	font-family: "Century Gothic", "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	color: rgb(192, 80, 77);
/*	color: rgb(11, 83, 149); */
	font-size: 13px;
	text-align: right;
	margin: 10px 0 5px 0;
	padding: 5px 4px;
}
.header-footer a {
	color: rgb(192, 80, 77);
	text-decoration: underline;
}
.header-footer a:focus, .header-footer a:hover {  /* change color and remove underline */
	text-decoration: none;
 	color: rgb(11, 83, 149);
/*	color: rgb(192, 80, 77); */
}

h1, h2, h3, h4, h5, h6 {  /* main title and sub-title */
	font-family: "Century Gothic", "Trebuchet MS", "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	margin: 0;
	color: rgb(10, 132, 100);
	letter-spacing: 1px;
	line-height: 1.2;
	text-align:left;
}
h1 {
	font-size: 40px;
	font-weight: 400;
	padding: 0.2em 0;
}
h2 {
	font-size: 36px;
	font-weight: 400;
	padding: 0.2em 0;
}
h3 {
	font-size: 22px;
	border-bottom: thin solid rgb(12, 155, 116);
	padding: 1.5em 0 0.3em 0;
}
h4 {
	font-family: "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	font-size: 18px;
	padding: 1.3em 0 0.2em 0;
	border-bottom: thin dotted rgb(12, 155, 116);
}
h5, h6 {
	font-family: "Segoe UI", Segoe, "Ubuntu", Verdana, Tahoma, Arial, Helvetica, sans-serif;
	font-size: 15px;
	color: #444;
	padding: 1.2em 0 0 0;  /* top right bottom left */
	letter-spacing: 1px;
}
.line-heading {
	color: #444;
	font-size: 15px;
	font-weight: bold;
	letter-spacing: 1px;
	padding: 0.2em 0;
}
.line-heading-code-new {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	color: #E31B23;
	font-size: 15px;
    font-weight: normal;
/*	letter-spacing: 0.5px; */
}
p {
	margin-top: 0.6em;
	margin-bottom: 0.4em;
}
pre {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	font-size: 13px;
	margin: 5px 0 8px 0;
	border: solid 2px #f8f8f8;  /* slight 3D shape */
	padding: 5px 10px;
	line-height: 135%;
}
code {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
}

ul {   /* first level ul */
	margin: 0.3em 0 0.2em 1.8em;
	padding: 0;
/*	list-style-type: square;  */
	list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAANAQMAAABBztZFAAAABlBMVEUAAwBjjJzG2b5OAAAAAXRSTlMAQObYZgAAABBJREFUCNdjYMAG7FARAwMADXkBNzRuJgIAAAAASUVORK5CYII=);
}
ul ul li {   /* 2nd level ul */
	list-style-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAANAQMAAABb8jbLAAAABlBMVEX///8AUow5QSOjAAAAAXRSTlMAQObYZgAAABNJREFUCB1jYEABBQw/wLCAgQEAGpIDyT0IVcsAAAAASUVORK5CYII=);
/*
	list-style-type: disc;
	list-style-image: none; */
}
ul ul u1 li {   /* 3rd level ul */
	list-style-type: circle;
	list-style-image: none;
}
ol {   /* first level ol */
/*    list-style-position:inside; */
/*    display: table  */
    list-style-type: decimal;
	margin: 0.3em 0 0.2em 2.5em;
	padding: 0;
}
ol ol li {   /* 2nd level ol */
	list-style-type: lower-alpha;
}
ol ol o1 li {  /* 3rd level ol */
	list-style-type: lower-roman;
}

li {
	margin: 0.4em 0;
}

.float-left-ol-ul {
	overflow:hidden;
}

/* li after a left-float image */
.float-left-li {
   position: relative; left: 20px;
   margin-right: 20px;
}

a {
	color: rgb(11, 83, 149);
	text-decoration: none;
}
a:hover, a:focus {
	color: rgb(192, 80, 77);
	text-decoration: underline;
}

a.references {
	display: block;
	width: 30em;
	font-size: 18px;
	font-weight: bold;
	margin: 4em 0 0 0;
}

p.references {
	font-size: 18px;
	font-weight: bold;
	margin: 4em 0 0 0;
}

/*
 * General classes
 */
.center-block {
	margin: 10px auto;  /* auto margin-left and margin-right to center the table */
}
.text-center {	
    text-align: center; 
}
.text-right {	
    text-align: right; 
}
.underline {
	text-decoration: underline;
}
.font-code {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
}
.font-code-text {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	font-size: 14px;
}
.font-code-smaller {
	font-family: Consolas, "Lucida Console", "Courier New", Courier, monospace;
	font-size: 13px;
}
.font-normal {
	font-family: "Segoe UI", Segoe, Calibri, "Ubuntu", Tahoma, Arial, Helvetica, Verdana, sans-serif;
}
.pre {
    white-space: pre;	
}
/* color control mainly for <pre>, <div>, <span> */
.color-example {
	background-color: rgb(215, 236, 211);  /* darker */
}
.color-example-light {
	background-color: rgb(236, 246, 234);  /* lighter */
}
.color-syntax, .color-command {
	background-color: rgb(204, 238, 241);  /* darker */
}
.color-explanation {
	background-color: #eee;   /* grey */
}
/* Character level control for code listing */
.color-comment {
	color: #009900;  /* green */
}
.color-new {
	color: #E31B23;  /* dark red to highlight new terms */
}
.color-error {
	color: #ff0099;  /* bright red */
/*	font-weight:bold; */
}
.color-plain {
	background-color: #fff;
}
.color-highlight {
	background-color: #ff0;
}
.color-highlight-new {
    background-color: #FFC;  /* lighter */
}

.output {  /* Output of program or DOS session */
    background-color: rgb(236, 246, 234);  /* lighter */
	border: solid 2px #f8f8f8;   /* slight 3D shape */
	padding: 4px 8px;
}
.side-note {
	margin-top: 15px;
    margin-left: 40px;
	padding: 3px 8px; 
	background-color: #e7e7e7;
}


/*
 * for positioning images 
 */
img.image-center {      /* center horizontally an image */
	display: block;
	margin: 10px auto;
}
img.image-border {
    border: #ddd thin solid;
}
img.image-float-left {
	float: left;
	margin: 8px 15px 15px 0;
    border: #ddd thin solid;
}
img.image-float-right {
	float: right;
	margin: 8px 0 15px 15px;
    border: #ddd thin solid;
}
.float-clear {
   clear: both;	
}
/*
 *  Table - for tablulating data with alternate row colors or different column colors
 */
table.table-zebra, table.table-program {
	border-collapse: collapse;
	border: 0;
	margin: 0 auto; /* center */
	padding: 0;
    width: 100%;
	/* Default setting for all cells in this table, inherited */
    background-color: rgb(231, 240, 248);  /* lighter */
	text-align: left;
	vertical-align: top;
}
table.table-zebra th {  /* header cells */
	color: #ffffff;     /* white text on dark background */
	background-color: rgb(0, 157, 217);
	margin: 0;
	border: 2px solid white;
	padding: 4px 10px;
	font-size: 15px;
	letter-spacing: 1px;
	text-align: center;
}
table.table-zebra td {  /* data cells */
    margin: 0;
	border: 2px solid white;
	padding: 2px 8px;
	/* color, font, text inherited from table */
	vertical-align: top;
}

table.table-program th {  /* header cells */
	color: #ffffff;     /* white text on dark background */
	background-color: rgb(0, 157, 217);
	margin: 0;
	border: 2px solid white;
	padding: 4px 10px;
	font-size: 15px;
	letter-spacing: 1px;
	text-align: center;
}
table.table-program td {  /* data cells */
    margin: 0;
	border: 0;
	padding: 0;
	/* color, font, text inherited from table */
}

table.table-program td pre {
	margin: 0;
	border: solid 2px #f8f8f8;   /* slight 3D shape */
	padding: 5px 10px;
}

table.table-program td pre.text-right {
	text-align: right;
}

/* Setting the color for row (2 colors) or column (3 colors) */
/* can only set the background, border, width of <col>, NOT font, text, color */
/* for table-zebra */
table .col-desc {       /* same as default color */
    background-color: rgb(231, 240, 248);  /* lighter */
}
table .col-code, table .tr-alt {
	background-color: rgb(203, 223, 241);  /* darker */
}
table .col-example {
    background-color: #eee;  /* grey */
}

/* for table-program */
table .col-line-number {
	width: 40px;
    background-color: rgb(225, 233, 207);
}
table .col-program {
    background-color: rgb(240, 244, 233);
}

/*
 * For the "Table of Content" generated by JavaScript
 * in <div id="toc">
 */
#wrap-toc {
    display: block;
	background: none repeat scroll 0 0 rgb(231, 246, 239);
	float: right;
	width: 230px;
	z-index: 100;
	line-height: 1.5;
	margin: 0 0 0 15px;
	padding: 5px 8px 10px 8px;
	text-align: left;
	white-space: nowrap;
/*	min-height: 180px;  */
}
#wrap-toc h5 {
   letter-spacing: 1px;
   margin: 0;
   text-transform: uppercase;
	color: #444;
	padding: 0.5em 0;
}
a#show-toc {
	color: rgb(192, 80, 77);
	text-decoration: none;
   letter-spacing: 1px;
}
#toc {
	overflow: auto;
}
#toc a.toc-H3 {
    margin-left: 0px;
	font-size: 15px;
}
#toc a.toc-H4 {
    margin-left: 20px;
	font-size: 14px;
}
#toc a.toc-H5 {
    margin-left: 40px;
	font-size: 14px;
}
</style>

<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAADy8O0APrMnACEdGADb2tkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMzMzMzMzMzMyIiIiIiIiIzIiIiIiIiIjMgIiIgAAAiMyACIiAAACIzIgAiIiIiIjMiIAIiIiIiMyIiACIiIiIzIiACIiIiIjMiACISEiESMyACIhISEiIzICIiERISIjMiIiISEhIiMyIiIhISIRIzIiIiIiIiIjMzMzMzMzMzMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" type="image/x-icon"></head>

<body class="">

<div id="wrap-outer" class="">

<!-- header filled by JavaScript -->
<div id="header" class="header-footer"><p class="">yet another insignificant programming notes... &nbsp;&nbsp;| &nbsp;&nbsp;<a href="http://www.ntu.edu.sg/home/ehchua/programming/index.html" class="">HOME</a></p></div>

<div id="wrap-inner" class="">

<div id="wrap-toc" class="">
<h5 class="">TABLE OF CONTENTS <a id="show-toc" href="#show-toc" class="">(HIDE)</a></h5>
<div id="toc" class=""><a class="toc-H3" href="#zz-1.">1.&nbsp;&nbsp;C++ Standard Libraries</a><br class=""><a class="toc-H4" href="#zz-1.1">1.1&nbsp;&nbsp;C Libraries and Headers</a><br class=""><a class="toc-H4" href="#zz-1.2">1.2&nbsp;&nbsp;C++ Libraries and Headers</a><br class=""><a class="toc-H4" href="#zz-1.3">1.3&nbsp;&nbsp;C++ Standard Template Libraries (STL) and Headers</a><br class=""><a class="toc-H4" href="#zz-1.4">1.4&nbsp;&nbsp;Boost C++ Libraries</a><br class=""><a class="toc-H3" href="#zz-2.">2.&nbsp;&nbsp;C++ Standard Template Library (STL)</a><br class=""><a class="toc-H4" href="#zz-2.1">2.1&nbsp;&nbsp;Let's Get Started with Examples of <span class="font-code">vector</span> STL Template Class</a><br class=""><a class="toc-H4" href="#zz-2.2">2.2&nbsp;&nbsp;The <span class="font-code">vector</span> Template Class</a><br class=""><a class="toc-H4" href="#zz-2.3">2.3&nbsp;&nbsp;Containers</a><br class=""><a class="toc-H4" href="#zz-2.4">2.4&nbsp;&nbsp;Iterator</a><br class=""><a class="toc-H4" href="#zz-2.5">2.5&nbsp;&nbsp;Algorithm</a><br class=""><a class="toc-H4" href="#zz-2.6">2.6&nbsp;&nbsp;Function Object (Functors)</a><br class=""><a class="toc-H4" href="#zz-2.7">2.7&nbsp;&nbsp;STL and the <span class="font-code">string</span> class</a><br class=""><a class="toc-H4" href="#zz-2.8">2.8&nbsp;&nbsp;<span class="font-code">vector</span>, <span class="font-code">valarray</span> and <span class="font-code">array</span></a><br class=""><a class="toc-H4" href="#zz-2.9">2.9&nbsp;&nbsp;STL Containers</a><br class=""><br class=""></div>  <!-- for showing the "Table of Content" -->
</div>

<div id="content-header" class="">
<h1 class="">C++ Programming Language</h1>
<h2 class="">C++ Standard Libraries and Standard Template Library (STL)</h2>
</div>

<div id="content-main" class="">

<h3 class="">1.&nbsp;&nbsp;C++ Standard Libraries<a id="zz-1." class="" style=""></a></h3>

<p class="">C++ provides  a huge set of libraries:</p>

<ol class="">
<li class="">Standard ANSI C library ported over to C++. These libraries are name with a prefix "<code class="">c</code>" and without the "<code class="">.h</code>", e.g., <code class="">&lt;cmath&gt;</code> for C's <code class="">&lt;math.h&gt;</code>, <code class="">&lt;cstdlib&gt;</code> for C's <code class="">&lt;stdlib.h&gt;</code>, etc.</li>
<li class="">C++ new Libraries, such as <code class="">&lt;iostream&gt;</code>, <code class="">&lt;iomanip&gt;</code>, <code class="">&lt;string&gt;</code>, <code class="">&lt;fstream&gt;</code>, <code class="">&lt;sstream&gt;</code>.</li>
<li class="">C++ Standard Template Library (STL): consists of containers,  iterators, algorithms and function objects.</li>
<li class="">Boost C++ libraries.</li>
</ol>

<p class="">The cplusplus.com at <a href="http://www.cplusplus.com/reference" class="">http://www.cplusplus.com/reference</a> provides a comprehensive online references for the C++ libraries (and updated for C++11).</p>

<h4 class="">1.1&nbsp;&nbsp;C Libraries and Headers<a id="zz-1.1" class="" style=""></a></h4>

<ul class="">
<li class=""><code class="">&lt;cstring&gt;</code>: To be elaborated later.</li>
<li class=""><code class="">&lt;cmath&gt;</code>: numeric mathematical library</li>
<li class=""><code class="">&lt;cstdlib&gt;</code>: General utilities such as Execution (<code class="">abort</code>, <code class="">exit</code>, <code class="">EXIT_SUCCESS</code>, <code class="">EXIT_FAILURE</code>); Environment (<code class="">getenv</code>); Dynamic Memory Management (<code class="">malloc</code>, <code class="">free</code>, <code class="">calloc</code>, <code class="">realloc</code>), String Parsing (<code class="">atoi</code>, <code class="">atof</code>, <code class="">atol</code>, <code class="">strtod</code>), Pseudo-random sequence generation (<code class="">rand</code>, <code class="">srand</code>, <code class="">RAND_MAX</code>); Array searching and sorting (<code class="">bsearch</code>, <code class="">qsort</code>).</li>
<li class=""><code class="">&lt;cctype&gt;</code>: Checking character types (<code class="">isalpha</code>, <code class="">isdigit</code>, <code class="">isalnum</code>, <code class="">isspace</code>, <code class="">isupper</code>, <code class="">islower</code>, <code class="">isblank</code>, <code class="">iscntrl</code>, <code class="">isgraph</code>, <code class="">isprint</code>, <code class="">ispunct</code>, <code class="">isxdigit</code>) and character conversion (<code class="">toupper</code>, <code class="">tolower</code>).</li>
<li class=""><code class="">&lt;climits&gt;</code>, <code class="">&lt;cfloat&gt;</code>: Size and limit of integer types (<code class="">INT_MAX</code>, <code class="">INT_MIN</code>, <code class="">UINT_MAX</code>, <code class="">CHAR_BIT</code>; and <code class="">SHRT_XXX</code> for <code class="">short</code>, <code class="">LONG_XXX</code> for <code class="">long</code>, <code class="">LLONG_XXX</code> for <code class="">long long</code>, <code class="">CHAR_XXX</code> for <code class="">char</code>) and floating-point types (<code class="">DBL_MIN</code>, <code class="">DBL_MAX</code>, <code class="">DBL_DIG</code>, <code class="">DBL_MIN_EXP</code>, <code class="">DBL_MAX_EXP</code>; and <code class="">FLT_XXX</code> for <code class="">float</code>, <code class="">LDBL_XXX</code> for <code class="">long double</code>).</li>
<li class=""><code class="">&lt;ctime&gt;</code>: <code class="">time</code>, <code class="">difftime</code>, <code class="">clock</code>, <code class="">gmttime</code>, <code class="">localtime</code>, and etc.</li>
<li class=""><code class="">&lt;cstdio&gt;</code>: C's IO operations (<code class="">scanf</code>, <code class="">printf</code>, <code class="">fscanf</code>, <code class="">fprintf</code>, <code class="">fopen</code>, <code class="">fclose</code>, etc)</li>
<li class=""><code class="">&lt;cassert&gt;</code>, <code class="">&lt;cerrno&gt;</code>, <code class="">&lt;csignal&gt;</code>: Diagnostics and error</li>
<li class=""><code class="">&lt;clocale&gt;</code>: localizaton</li>
<li class=""><code class="">&lt;cstdbool&gt;</code>, <code class="">&lt;cstdint&gt;</code>, <code class="">&lt;cstddef&gt;</code>, <code class="">&lt;cstdarg&gt;</code>:</li>
<li class=""><code class="">&lt;cuchar&gt;</code>, <code class="">&lt;cwchar&gt;</code>, <code class="">&lt;cwcchar&gt;</code>: Unicode characters.</li>
</ul>

<h4 class="">1.2&nbsp;&nbsp;C++ Libraries and Headers<a id="zz-1.2" class="" style=""></a></h4>
<ul class="">
<li class=""><code class="">&lt;ios&gt;</code>, <code class="">&lt;iostream&gt;</code>, <code class="">&lt;istream&gt;</code>, <code class="">&lt;ostream&gt;</code>, <code class="">&lt;fstream&gt;</code>, <code class="">&lt;sstream&gt;</code>:</li>
<li class=""><code class="">&lt;iomanip&gt;</code>:</li>
<li class=""><code class="">&lt;string&gt;</code>:</li>
<li class=""><code class="">&lt;regex&gt;</code>:</li>
<li class=""><code class="">&lt;random&gt;</code>:</li>
<li class=""><code class="">&lt;limits&gt;</code>:</li>
<li class=""><code class="">&lt;stdexcept&gt;</code>, <code class="">&lt;exception&gt;</code>:</li>
<li class=""><code class="">&lt;complex&gt;</code>, <code class="">&lt;tuple&gt;</code>, <code class="">&lt;valarray&gt;</code>:</li>
<li class=""><code class="">&lt;locale&gt;</code>:</li>
<li class=""><code class="">&lt;typeinfo&gt;</code>:</li>
<li class=""><code class="">&lt;chrono&gt;</code>:</li>
<li class="">Others: <code class="">&lt;codecvt&gt;</code>, <code class="">&lt;new&gt;</code>, <code class="">&lt;ratio&gt;</code>, <code class="">&lt;system_error&gt;</code>, <code class="">&lt;type_traits&gt;</code>.</li>
</ul>

<table class="table-program">
<tbody class=""><tr class="">
<th class="">FUNCTION</th>
<th class="">EXAMPLE</th>
</tr>

<tr class="">
<td class=""><pre class="color-syntax"><strong class="">int atoi(char* s)</strong>
  Parse string s into an int</pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 </pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax"><strong class="">double atof(char* s)</strong>
  Parse string s into a double</pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 </pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax"><strong class="">int rand(void)</strong>
  Generate a random number between 0 and RAND_MAX (&gt;32767)
<strong class="">void srand (unsigned int seed)</strong>
  Initialize (Seed) the random number generator</pre></td>
<td class="">
<pre class="color-example">rand() % 100     <span class="color-comment">// between 0 and 99</span>
rand() % 100 + 1 <span class="color-comment">// between 1 and 100</span>
 
 </pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax"><strong class="">void exit(int status)</strong>: Exit with status code
<strong class="">void abort(void)</strong>: Abort current process
<strong class="">int system(const char *command)</strong>: Execute system command
<strong class="">char* getenv(const char *param)</strong>: Get environment parameter's value</pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
 
 
 </pre></td>
</tr>

<tr class="">
<td class="">
<pre class="color-syntax"><strong class="">EXIT_SUCCESS, EXIT_FAILURE</strong>: System-dependent return code for success and failure</pre></td>
<td class="" style="">
<pre class="color-example" style=""> 
</pre></td>
</tr>
</tbody></table>


<h4 class="">1.3&nbsp;&nbsp;C++ Standard Template Libraries (STL) and Headers<a id="zz-1.3" class="" style=""></a></h4>

<p class="">STL was developed by Alexander Stepanov and Meng Lee at Hewlett-Packard Lab as proof-of-concept for so-called <em class="">generic programming</em>. It was released in 1994 and subsequently adopted into the C++98.</p>

<p class=""> STL provides a collection of templates representing <em class="">containers</em>, <em class="">iterators</em>,  <em class="">algorithms</em> and <em class="">function objects</em>.</p>

<ol class="">
<li class="">A <em class="">container</em> (templatized data structure) can be used to hold fundamental-type values or almost any type of objects, e.g., <code class="">vector&lt;int&gt;</code>, <code class="">list&lt;string&gt;</code>, <code class="">deque&lt;Person&gt;</code>.</li>
<li class="">An <em class="">iterator</em> (a generalization of pointer) is an object that lets you transverse through elements of a container, e.g., <code class="">vector&lt;int&gt;::iterator</code>, <code class="">list&lt;string&gt;::iterator</code>.</li>
<li class=""><em class="">Algorithms</em> are used for tasks such as searching, sorting and comparison, e.g., <code class="">for_each</code>, <code class="">find</code>, <code class="">sort</code>.</li>
<li class=""><em class="">Function objects</em> are objects that act like functions.</li>
</ol>

<p class="">STL is provided in the following  headers:</p>
<ul class="">
<li class=""><code class="">&lt;vector&gt;</code>,<code class=""> &lt;list&gt;</code>, <code class="">&lt;deque&gt;</code>, <code class="">&lt;queue&gt;</code>, <code class="">&lt;stack&gt;</code>, <code class="">&lt;map&gt;</code>, <code class="">&lt;set&gt;</code>, <code class="">&lt;bitset&gt;</code>, <code class="">&lt;forward_list&gt;</code> (C++11), <code class="">&lt;unordered_map&gt;</code> (C++11), <code class="">&lt;unordered_set&gt;</code> (C++11), <code class="">&lt;array&gt;</code> (C++11): Containers data structures template classes.</li>
<li class=""><code class="">&lt;iterator&gt;</code>: Iterator for transversing the elements in a container.</li>
<li class=""><code class="">&lt;algorithm&gt;</code>, <code class="">&lt;numeric&gt;</code><code class="" style=""></code>, <code class="">&lt;functional&gt;</code>, <code class="">&lt;utility&gt;</code>: Algorithm and function objects.</li>
<li class=""><code class="">&lt;initializer_list&gt;</code> (C++11), <code class="">&lt;memroy&gt;</code> (C++11).</li>
</ul>

<h4 class="">1.4&nbsp;&nbsp;Boost C++ Libraries<a id="zz-1.4" class="" style=""></a></h4>

<p class="">[TODO]</p>

<h3 class="">2.&nbsp;&nbsp;C++ Standard Template Library (STL)<a id="zz-2." class="" style=""></a></h3>

<p class="" style=""></p>

<h4 class="">2.1&nbsp;&nbsp;Let's Get Started with Examples of <span class="font-code">vector</span> STL Template Class<a id="zz-2.1" class="" style=""></a></h4>
<p class="">In computing, a vector refers to an array-like structure that holds a set of direct-access elements of the same kinds, instead of mathematical n-component vector. Unlike array which is fixed-size, vector is dynamically-sized. <code class="">vector</code> is a class template, declared in the <code class="">vector</code> header.</p>

<p class="">Let's begin with some examples.</p>

<h5 class="">Example 1: Construct <span class="font-code">vector&lt;&gt;</span> object and access its elements</h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></td>
<td class="">
<pre class=""><span class="color-comment">/* Test vector class element access  (TestVectorIndex.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;vector&gt;
using namespace std;
 
void print(const vector&lt;int&gt; &amp; v);
 
int main() {
   const int SIZE = 10;
   vector&lt;int&gt; numbers(SIZE); <span class="color-comment"> // Declare vector of int of SIZE elements, init to 0</span>
 
   cout &lt;&lt; "size = " &lt;&lt; numbers.size() &lt;&lt; endl;
   cout &lt;&lt; "capacity = " &lt;&lt; numbers.capacity() &lt;&lt; endl;
   print(numbers);
 
  <span class="color-comment"> // Assign random numbers into vector</span>
   srand(time(0)); <span class="color-comment"> // Seed the pseudo-random number generator</span>
   for (size_t i = 0; i &lt; numbers.size(); ++i) {
      numbers.at(i) = rand() % 100; <span class="color-comment"> // at() did bound check</span>
   }
   print(numbers);
 
   cout &lt;&lt; "First element is " &lt;&lt; numbers.front() &lt;&lt; endl;
   cout &lt;&lt; "Last element is " &lt;&lt; numbers.back() &lt;&lt; endl;
 
  <span class="color-comment"> // [] does not perform index bound check, but at() does</span>
   cout &lt;&lt; numbers[55] &lt;&lt; endl;   <span class="color-comment"> // no error compile and run</span>
<span class="color-comment">//</span> cout &lt;&lt; numbers.at(55) &lt;&lt; endl;<span class="color-comment"> // runtime out_of_range exception</span>
   return 0;
}
 
<span class="color-comment">// Print the content of this vector using indexing operator []</span>
void print(const vector&lt;int&gt; &amp; v) {
   for (int i = 0; i &lt; v.size(); ++i) {
      cout &lt;&lt; v[i] &lt;&lt; " "; <span class="color-comment"> // no bound check, but safe here</span>
   }
   cout &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class=""><code class="">vector</code> is a template class. We create an <code class="">int</code> specialization via <code class="">vector&lt;int&gt;</code>. We create a <code class="">vector&lt;int&gt;</code> object via constructor <code class="">vector&lt;int&gt; numbers(SIZE);</code> which allocates <code class="">SIZE</code> elements and initializes to 0.</li>
<li class="">The <code class="">size()</code> member function returns the number of elements. The <code class="">capacity()</code> returns the storage allocated. All STL containers dynamically allocate storage.</li>
<li class="">Elements in <code class="">vector</code> has a linear order index. You can use <code class="">[]</code> overloaded operator or <code class="">at()</code> member function to access the n-th element. Take note that <code class="">[]</code> does not perform index-bound check; but <code class="">at()</code> does at runtime and throws <code class="">out_of_range</code> exception if index exceeds bound.</li>
<li class="">The member function <code class="">front()</code> and <code class="">back()</code> returns the first and last element respectively.</li>
</ul>

<h5 class="">Example 2: Using <span class="font-code">push_back()</span> and <span class="font-code">pop_back()</span> to add and remove element</h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></td>
<td class="">
<pre class=""><span class="color-comment">/* Test modifying vector class's element (TestVectorMod.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;vector&gt;
using namespace std;
 
void print(const vector&lt;int&gt; &amp; v);
 
int main() {
   vector&lt;int&gt; numbers; <span class="color-comment"> // Declare vector of int with initial size of 0</span>
   cout &lt;&lt; "size = " &lt;&lt; numbers.size() &lt;&lt; endl;
   cout &lt;&lt; "capacity = " &lt;&lt; numbers.capacity() &lt;&lt; endl;
 
  <span class="color-comment"> // Assign random numbers into vector</span>
   srand(time(0));
   for (int i = 0; i &lt; 5; ++i) {
      numbers.push_back(rand() % 100);
        <span class="color-comment"> // Append element at the end - vector resize automatically</span>
   }
   print(numbers);
   cout &lt;&lt; "size = " &lt;&lt; numbers.size() &lt;&lt; endl;
   cout &lt;&lt; "capacity = " &lt;&lt; numbers.capacity() &lt;&lt; endl;
 
   numbers.pop_back();<span class="color-comment"> // Remove the last element - size reduces by 1</span>
   numbers.pop_back();
   print(numbers);
   cout &lt;&lt; "size = " &lt;&lt; numbers.size() &lt;&lt; endl;
   cout &lt;&lt; "capacity = " &lt;&lt; numbers.capacity() &lt;&lt; endl;
 
   numbers.clear(); <span class="color-comment"> // Remove all elements</span>
   cout &lt;&lt; "size = " &lt;&lt; numbers.size() &lt;&lt; endl;
   cout &lt;&lt; "capacity = " &lt;&lt; numbers.capacity() &lt;&lt; endl;
   return 0;
}
 
<span class="color-comment">// Print the content of this vector using indexing operator []</span>
void print(const vector&lt;int&gt; &amp; v) {
   for (int i = 0; i &lt; v.size(); ++i) {
      cout &lt;&lt; v[i] &lt;&lt; " "; <span class="color-comment"> // no bound check, but safe here</span>
   }
   cout &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">The default constructor <code class="">vector&lt;int&gt; numbers</code> construct a vector object with size of 0.</li>
<li class="">The member function <code class="">push_back()</code> appends the item at the end; while <code class="">pop_back()</code> removes the last element.</li>
</ul>

<h5 class="">Example 3: Using iterator to access the container</h5>

<p class="">We can use a special object called <em class="">iterator</em> to iterate through all the elements of a STL container, such as <code class="">vector</code>. The <code class="">vector</code> class provides a pair of functions <code class="">begin()</code> and <code class="">end()</code> to work with iterator. To use iterator:</p>
<pre class="color-example"><span class="color-comment">// Declare a vector</span>
vector&lt;int&gt; aVector(10);
<span class="color-comment">// Declare an iterator called iter for vector&lt;int&gt;</span>
vector&lt;int&gt;::iterator iter;
<span class="color-comment">// Assign iter to the beginning of the vector</span>
iter = aVector.begin()
<span class="color-comment">// Use *iter to access the current element</span>
cout &lt;&lt; *iter &lt;&lt; endl;
<span class="color-comment">// Next element</span>
++iter;
<span class="color-comment">// The pass-the-end element is aVector.end() - to be excluded</span></pre>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* Test vector class's iterator (TestVectorIterator.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
using namespace std;
 
void print(vector&lt;string&gt; &amp; v);
 
int main() {
   vector&lt;string&gt; strs;
   strs.push_back("apple");
   strs.push_back("orange");
   strs.push_back("banana");
   print(strs);
   cout &lt;&lt; "size = " &lt;&lt; strs.size() &lt;&lt; endl;
 
  <span class="color-comment"> // Test insert()</span>
   strs.insert(strs.begin() + 2, "b4-banana");
   strs.insert(strs.begin() + 1, 2, "b4-orange");
   print(strs);
   cout &lt;&lt; "size = " &lt;&lt; strs.size() &lt;&lt; endl;
 
  <span class="color-comment"> // Test erase()</span>
   strs.erase(strs.begin() + 1, strs.begin() + 4);
   print(strs);
   cout &lt;&lt; "size = " &lt;&lt; strs.size() &lt;&lt; endl;
 
  <span class="color-comment"> // insert() from another vector</span>
   vector&lt;string&gt; newStrs;
   newStrs.push_back("1");
   newStrs.push_back("2");
   newStrs.push_back("3");
   strs.insert(strs.begin() + 1, newStrs.begin(), newStrs.end());
   print(strs);
   cout &lt;&lt; "size = " &lt;&lt; strs.size() &lt;&lt; endl;
}
 
<span class="color-comment">// Use iterator to iterate thru the entire vector</span>
void print(vector&lt;string&gt; &amp; v) {
   for (vector&lt;string&gt;::iterator iter = v.begin(); iter != v.end(); ++iter) {
      cout &lt;&lt; *iter &lt;&lt; " ";  <span class="color-comment"> // dereference</span>
   }
   cout &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Program Notes:</p>

<ul class="">
<li class="">Each container class defines its suitable iterator, with type name of <code class="">vector&lt;T&gt;::iterator</code>.</li>
<li class="">The <code class="">vector</code>'s member function <code class="">begin()</code> and <code class="">end()</code> returns an iterator to the first element and the <em class="">pass-the-end</em> element, respectively. The pass-the-end element shall be excluded, i.e., <code class="">[begin(), end())</code>.</li>
<li class="">Iterator works like pointer, you can use <code class="">*iter</code> (dereferencing operator) to retrieve the vector element; <code class="">++iter</code> (increment operator) to move to the next element; <code class="">iter+n</code> to point to the <code class="">+n</code> element.</li>
<li class="">The <code class="">insert()</code> and <code class="">erase()</code> member functions works on the iterator as well. <code class="">insert(iter, item)</code> inserts item before the iter-element. <code class="">insert(insert, n, item)</code> fills <code class="">n</code> element before the iter-element. <code class="">erase(fist, last)</code> removes all element in <code class="">[first, last)</code>.</li>
<li class="">In C++11, you can use the <code class="">auto</code>  as the type of iterator, which asks the compiler to deduce the type automatically.
<pre class="color-example">for (<span class="color-new">auto</span> iter = strs.begin(); iter != strs.end(); ++iter) {
   cout &lt;&lt; *iter &lt;&lt; " ";          <span class="color-comment"> // Print string</span>
}
cout &lt;&lt; endl;</pre></li>

<li class="">C++ introduces for-each loop, which can be used to iterate thru all the items of an array or a container:
  <pre class="color-example">for (<span class="color-new">auto</span> item : strs) {
   cout &lt;&lt; item &lt;&lt; " ";
}
cout &lt;&lt; endl;</pre>
</li>
</ul>

<h4 class="">2.2&nbsp;&nbsp;The <span class="font-code">vector</span> Template Class<a id="zz-2.2" class="" style=""></a></h4>

<p class="">Let's take a closer look at the <code class="">vector</code> template class, which serve as a sample for all the STL container classes.</p>

<h5 class="">Constructor</h5>

<pre class="color-syntax"><strong class="">vector</strong> (const allocator_type &amp; alloc = allocator_type());
   <span class="color-comment">// Default Constructor: construct a vector object</span>
<strong class="">vector</strong> (size_type n, const value_type &amp; val = value_type(),
        const allocator_type &amp; alloc = allocator_type());
   <span class="color-comment">// Fill Constructor: construct a vector object with n-element filled with val</span>
<strong class="">vector</strong> (const vector &amp; v);
   <span class="color-comment">// Copy Constructor</span>
template &lt;class InputIterator&gt;
<strong class="">vector</strong> (InputIterator first, InputIterator last,
        const allocator_type &amp; alloc = allocator_type());
   <span class="color-comment">// Range Copy Constructor</span></pre>

<h5 class="">Size and Capacity</h5>

<pre class="color-syntax">size_type <strong class="">size</strong> () const;      <span class="color-comment">// Return the size (number of elements)</span>
size_type <strong class="">capacity</strong> () const;  <span class="color-comment">// Return the storage allocated (in term of element)</span>
bool <strong class="">empty</strong> () const;          <span class="color-comment">// Return true if size is 0</span>
void <strong class="">reserve</strong> (size_type n);   <span class="color-comment">// Request for storage to hold n elements</span>
void <strong class="">resize</strong> (size_type n, value_type val = value_type());
      <span class="color-comment">// resize to n, remove extra element or fill with val</span>
size_type <strong class="">max_size</strong> () const;  <span class="color-comment">// Return the maximum number of element</span>
void <strong class="">shrink_to_fit</strong> ();        <span class="color-comment">// (C++11) Request to shrink storage</span></pre>

<h5 class="">Accessing Element</h5>

<pre class="color-syntax">value_type &amp; <strong class="">operator[]</strong> (size_type n);  <span class="color-comment">// [n] operator (without index-bound check)</span>
value_type &amp; <strong class="">at</strong> (size_type n);          <span class="color-comment">// Return a reference to n-th element with index-bound check</span>
value_type &amp; <strong class="">front</strong> ();    <span class="color-comment">// Return a reference to the first element</span>
value_type &amp; <strong class="">back</strong> ();     <span class="color-comment">// Return a reference to the last element</span></pre>

<h5 class="">Modifying Contents</h5>

<pre class="color-syntax">void <strong class="">push_back</strong> (const value_type &amp; val); <span class="color-comment">// Append val at the end</span>
void <strong class="">pop_back</strong> ();                        <span class="color-comment">// Remove the last element</span>
void <strong class="">clear</strong> ();                           <span class="color-comment">// Remove all elements</span></pre>

<h5 class="">Non-member Friend Functions</h5>

<pre class="color-syntax"><strong class="">==</strong>, <strong class="">!=</strong>, <strong class="">&lt;</strong>, <strong class="">&gt;</strong>, <strong class="">&lt;=</strong>, <strong class="">&gt;=</strong>    <span class="color-comment">// Comparison Operators</span>
<span class="color-comment">// E.g.</span>
template &lt;class T, class Alloc&gt;
bool <strong class="">operator==</strong> (const vector&lt;T,Alloc&gt; &amp; left, const vector&lt;T, Alloc&gt; &amp; right);
   <span class="color-comment">// Compare two vectors
   // For == and !=, first compare the size, then each element with equal algorithm.
   //   Stop at the first mismatch.
   // For &lt;, &gt;, &lt;=, &gt;=, use lexicographical_compare algorithm. Stop at first mismatch.</span>
 
template &lt;class T, class Alloc&gt;
void <strong class="">swap</strong> (vector&lt;T,Alloc&gt; &amp; v1, vector&lt;T,Alloc&gt; v2);
   <span class="color-comment">// Swap the contents of containers v1 and v2.
   // Both shall has the same type, but can have different sizes.</span></pre>

<h5 class="">Iterator</h5>

<pre class="color-syntax">iterator <strong class="">begin</strong>();  <span class="color-comment">// Return an iterator pointing to the first element</span>
iterator <strong class="">end</strong>();    <span class="color-comment">// Return an iterator pointing to the pass-the-end element</span>
 
reverse_iterator <strong class="">rbegin</strong>(); <span class="color-comment">// Return a reverse iterator pointing to the reverse beginning (last element)
                           // increasing a reverse iterator to transverse in reverse order</span>
reverse_iterator <strong class="">rend</strong>();   <span class="color-comment">// Return a reverse iterator pointing to the reverse past-the-end</span></pre>

<h5 class="">Iterator-based Operations</h5>

<pre class="color-syntax">iterator <strong class="">insert</strong> (iterator pos, const value_type &amp; val);  <span class="color-comment">// Single-Element: insert element val before iterator pos</span>
void     <strong class="">insert</strong> (iterator pos, size_type n, const value_type &amp; val);  <span class="color-comment">// Fill: insert n copies of val before pos</span>
template &lt;class InputIterator&gt;
void     <strong class="">insert</strong> (iterator pos, InputIterator first, InputIterator last)
    <span class="color-comment">// Range-copy: copy the range [first, last) and insert before pos.</span>
 
iterator <strong class="">erase</strong> (iterator pos);  <span class="color-comment">// Single-element: remove element pointed to by iterator pos</span>
iterator <strong class="">erase</strong> (iterator first, iterator last);  <span class="color-comment">// Range: remove elements between [first,last)</span>
 
void <strong class="">assign</strong> (size_type n, const value_type &amp; val);  <span class="color-comment">// Fill: clear old contents and assign n copies of val</span>
template &lt;class InputIterator&gt;
void <strong class="">assign</strong> (InputIterator first, InputIterator last);  <span class="color-comment">// Range: assign [first, last)</span></pre>

<p class="">[TODO] Example</p>

<h4 class="">2.3&nbsp;&nbsp;Containers<a id="zz-2.3" class="" style=""></a></h4>

<h5 class="">Sequence Containers, Associative Containers and Adapters</h5>

<p class="">STL provides the following types of containers:</p>

<ol class="">
<li class="">Sequence Containers: linear data structures of elements
  <ul class="">
<li class=""><code class="">vector</code>: dynamically resizable array. Support fast insertion and deletion at <em class="">back</em>; and direct access to its elements.</li>
<li class=""><code class="">deque</code>: double-ended queue. Support fast insertion and deletion at <em class="">front and back</em>; and direct access to its elements.</li>
<li class=""><code class="">list</code>: double-linked list. Support fast insertion and deletion <em class="">anywhere</em> in the list; and direct access to its elements.</li>
</ul>
</li>

<li class="">Associative Containers: nonlinear data structures storing key-value pairs
  <ul class="">
<li class=""><code class="">set</code>: No duplicate element. Support fast lookup.</li>
<li class=""><code class="">multiset</code>: Duplicate element allowed. Support fast lookup.</li>
<li class=""><code class="">map</code>: One-to-one mapping (associative array) with no duplicate. Support fast key lookup.</li>
<li class=""><code class="">multimap</code>: One-to-many mapping, with duplicates allowed. Support fast key lookup.</li>
</ul>
</li>

<li class="">Container Adapter Classes:
  <ul class="">
<li class=""><code class="">Stack</code>: Last-in-first-out (LIFO) queue, adapted from <code class="">deque</code> (default), or <code class="">vector</code>, or <code class="">list</code>. Support operations <code class="">back</code>, <code class="">push_back</code>, <code class="">pop_back</code>.</li>
<li class=""><code class="">queue</code>: First-in-first-out (FIFO) queue, adapted from <code class="">deque</code> (default), or <code class="">list</code>. Support operations <code class="">front</code>, <code class="">back</code>, <code class="">push_back</code>, <code class="">pop_front</code>.</li>
<li class=""><code class="">priority_queue</code>: highest priority element at front of the queue. adapted from <code class="">vector</code> (default) or <code class="">deque</code>. Support operations <code class="">front</code>, <code class="">push_back</code>, <code class="">pop_front</code>.</li>
</ul>
</li>
</ol>

<h5 class="">First-class Containers, Adapters and Near Containers</h5>

<p class="">The containers can also be classified as:</p>
<ol class="">
<li class="">First-class Containers: all sequence containers and associative containers are collectively known as first-class container.</li>
<li class="">Adapters: constrained first-class containers such as <code class="">stack</code> and <code class="">queue</code>.</li>
<li class="">Near Containers: Do not support all the first-class container operations. For example, the built-in array (pointer-like), <code class="">bitsets</code> (for maintaining a set of flags), <code class="">valarray</code> (support array computation), <code class="">string</code> (stores only character type).</li>

</ol>

<h5 class="">Container's Functions</h5>

<p class="">All containers provides these functions:</p>
<ul class="">
<li class="">Default Constructor: to construct an empty container. Other constructors are provided for specific purposes.</li>
<li class="">Copy Constructor:</li>
<li class="">Destructor:</li>
<li class=""><code class="">empty()</code>: returns true if the container is empty.</li>
<li class=""><code class="">size()</code>: returns the size (number of elements).</li>
<li class="">Assignment Operator (<code class="">=</code>)</li>
<li class="">Comparison Operators (<code class="">==</code>, <code class="">!=</code>, <code class="">&lt;</code>, <code class="">&lt;=</code>, <code class="">&gt;</code>, <code class="">&gt;=</code>).</li>
<li class=""><code class="">swap()</code>: exchanges the contents of two containers.</li>
</ul>

<p class="">In addition, the first-class containers support these functions:</p>

<ul class="">
<li class=""><code class="">begin</code>, <code class="">end</code>, <code class="">cbegin</code>, <code class="">cend</code>: Returns the begin and end <code class="">iterator</code>, or the <code class="">const</code> version.</li>
<li class=""><code class="">rbegin</code>, <code class="">rend</code>, <code class="">crbegin</code>, <code class="">crend</code>: Returns the <code class="">reverse_iterator</code>.</li>
<li class=""><code class="">clear()</code>: Removes all elements.</li>
<li class=""><code class="">erase()</code>: Removes one element given an iterator, or a range of elements given [begin, end) iterators.</li>
<li class=""><code class="">max_size()</code>: Returns the maximum number of elements that the container can hold.</li>
</ul>

<h5 class="">Container Header</h5>

<ul class="">
<li class=""><code class="">&lt;vector&gt;</code></li>
<li class=""><code class="">&lt;list&gt;</code></li>
<li class=""><code class="">&lt;deque&gt;</code></li>
<li class=""><code class="">&lt;queue&gt;</code>: <code class="">queue</code> and <code class="">priority_queue</code></li>
<li class=""><code class="">&lt;stack&gt;</code></li>
<li class=""><code class="">&lt;map&gt;</code>: <code class="">map</code> and <code class="">multimap</code></li>
<li class=""><code class="">&lt;set&gt;</code>: <code class="">set</code> and <code class="">multiset</code></li>
<li class=""><code class="">&lt;valarray&gt;</code></li>
<li class=""><code class="">&lt;bitset&gt;</code></li>
<li class=""><code class="">&lt;array&gt;</code> (C++11)</li>
<li class=""><code class="">&lt;forward_list&gt;</code> (C++11)</li>
<li class=""><code class="">&lt;unordered_map&gt;</code> (C++11)</li>
<li class=""><code class="">&lt;unordered_set&gt;</code> (C++11)</li>



</ul>


<h4 class="">2.4&nbsp;&nbsp;Iterator<a id="zz-2.4" class="" style=""></a></h4>

<p class="">An <em class="">iterator</em> behaves like a <em class="">generic pointer</em>, which can be used to reference (point-to) individual element of a generic container; and transverse through elements of a container. The purpose of iterator is to make transversing (iterating) of containers independent on the type of the containers (e.g., <code class="">vector&lt;int&gt;</code>, <code class="">queue&lt;double&gt;</code>, <code class="">stack&lt;string&gt;</code>). With iterator, you can apply <em class="">generic algorithm</em> (such as searching, sorting and comparison) to the container, independent of types. Without iterator, you may need to write different codes for the same algorithm for different containers (e.g., different codes for searching an <code class="">vector&lt;int&gt;</code>, <code class="">vector&lt;double&gt;</code>, <code class="">stack&lt;string&gt;</code>).</p>
<p class="">Iterator abstracts pointer and works like pointer. It could actually be implemented as pointer, but that is totally up to the compiler. Iterator shall meet the following requirements:</p>

<ul class="">
<li class="">The dereferencing operator <code class="">*</code> shall be defined. That is, if <code class="">iter</code> is an iterator, <code class="">*iter</code> shall be pointing to an element of the container.</li>

<li class="">The assignment operator <code class="">=</code> shall be defined. That is, if <code class="">iter1</code> and <code class="">iter2</code> are iterators, <code class="">iter1 = iter2</code> shall assign <code class="">iter2</code> to <code class="">iter1</code>.</li>

<li class="">The comparison operators <code class="">==</code> and <code class="">!=</code> shall be defined. That is, if <code class="">iter1</code> and <code class="">iter2</code> are iterators, we can use <code class="">iter1 == iter2</code> and <code class="">iter1 != iter2</code> to compare them for equality. If <code class="">iter1 == iter2</code> is true, then they shall be pointing at the same element, i.e., <code class="">*iter1 == *iter2</code>.</li>

<li class="">The increment operator <code class="">++</code> shall be defined. That is, if <code class="">iter</code> is an iterator, <code class="">++iter</code> and <code class="">iter++</code> move the iterator to point to the next element. The program shall be able to iterate through all the elements via <code class="">++iter</code> (or <code class="">iter++</code>) operations.</li>
</ul>

<p class="">In addition,</p>

<ul class="">
<li class="">For <em class="">linearly-ordered</em> container, the <code class="">+</code> (and <code class="">+=</code>) operator shall be defined. That is, if <code class="">iter</code> is an iterator, <code class="">iter+n</code> points to the next <code class="">n</code>-th element in the linear order.</li>

<li class="">For iterator that can transverse backward, the decrement operator <code class="">--</code> shall be defined. That is, if <code class="">iter</code> is an operator, <code class="">--iter</code> and <code class="">iter--</code> move the iterator to point to the next element in the reverse order (or previous element in the forward order).</li>
</ul>

<p class="">All STL container provides two member functions: <code class="">begin()</code> and <code class="">end()</code> that return the iterators pointing to the first element and the <em class="">pass-the-end</em> element respectively. Hence, you can use the following code to transverse all the elements in the container:</p>

<pre class="color-example"><span class="color-comment">// Assume that c is a container</span>
<em class="">iter_type</em> iter;
for (iter = c.begin(); iter != c.end(); ++iter) {
   <span class="color-comment">// Use *iter to reference each element</span>
   ......
}</pre>

<p class="">Take note that the above code work for all STL containers with any type specialization. The type of iterator (<em class=""><code class="">iter_type</code></em><code class="" style=""></code>) depends on the container. In STL, you can get the iterator type via <code class=""><em class="">container</em>&lt;<em class="">T</em>&gt;::iterator</code>.</p>
<p class="">By convention, if a range of elements is specified by two iterators: <code class="">first</code> and <code class="">last</code>, then <code class="">first</code> is included and <code class="">last</code> is excluded, denoted as <code class="">[first, last)</code>.</p>

<p class="">In C++11, you can use the <code class="">auto</code> to derive the type of iterator automatically, as follows:</p>

<pre class="color-example">for (<span class="color-new">auto</span> iter = c.begin(); iter != c.end(); ++iter) {
   <span class="color-comment">// Use *iter to reference each element</span>
   ......
}</pre>

<p class="">In C++11, you can also use the new for-each loop to iterate thru all the element of a container:</p>

<pre class="color-example">for (auto item : container) {
   <span class="color-comment">// Use item to reference each element</span>
   ......
}</pre>

<h5 class="">Types of Iterators</h5>

<p class="">STL defines the following types of iterators with different requirements. All iterators shall define <code class="">*</code> (dereferencing), <code class="">=</code> (assignment) and <code class="">==</code>, <code class="">!=</code> (equality comparison) operators.</p>

<ol class="">
<li class="">Input Iterator: can be used to read element from a container (may not support write operation). It defines <code class="">++</code> (prefix and postfix) to transverse thru all the elements of a container in a <em class="">single pass</em> - but no guarantee that different passes will transverse through the elements in the same order. Input iterator can be used for single-pass, read-only algorithms.</li>
<li class="">Output Iterator: Similar to input iterator, but the dereferencing operator support write operation (may not support read operation). Output iterator can be used for single-pass, write-only algorithms.</li>
<li class="">Forward Iterator: the <code class="">++</code> operator transverses thru the elements, and always in the same order (in different passes). It support both read and write operations.</li>
<li class="">Bidirectional Iterator: a forward iterator with added support for <code class="">--</code> (decrement, prefix and postfix) to transverse in the opposite direction.</li>
<li class="">Random-access (Direct-access) Iterator: support <code class="">+</code>, <code class="">-</code>, <code class="">+=</code>, <code class="">-+</code> (e.g., <code class="">iter+n</code>, <code class="">iter-n</code>) to directly access any element in constant time.</li>
</ol>

<p class="">In STL, each container class (such as <code class="">vector</code>) has a class scope <code class="">typedef</code> called <code class="">iterator</code>, which specifies the type of the iterator. For example, <code class="">vector&lt;int&gt;</code>'s iterator is called <code class="">vector&lt;int&gt;::iterator</code>; <code class="">stack&lt;string&gt;</code> is <code class="">stack&lt;string&gt;::iterator</code>.</p>

<h5 class="">STL Pre-defined Iterators (in Header <span class="font-code">&lt;iterator&gt;</span>)</h5>
<p class="">STL pre-defined many iterators (in header <code class="">&lt;iterator&gt;</code>): <code class="">iterator</code>, <code class="">reverse_iterator</code>, <code class="">insert_iterator</code>, <code class="">front_insert_iterator</code>, <code class="" style=""></code> <code class="" style=""></code> <code class="">back_insert_iterator</code>, <code class="">istream_iterator</code>, <code class="">ostream_iterator</code>, <code class="" style=""></code><code class="">istreambuf_iterator</code>, and <code class="">ostreambuf_iterator</code>.</p>

<h5 class="">Example: <span class="font-code">istream_iterator</span> and <span class="font-code">ostream_iterator</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/* Testing istream_iterator and ostream_iterator (TestIOIterator.cpp) */</span>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;iterator&gt;
using namespace std;
 
int main() {
  <span class="color-comment"> // Construct ostream_iterators to write int and string to cout</span>
   ostream_iterator&lt;int&gt; iterOut(cout);
   ostream_iterator&lt;string&gt; iterOutStr(cout);
 
   *iterOutStr = "Enter two integers: ";
 
  <span class="color-comment"> // Construct an istream_iterator&lt;int&gt; to read int from cin</span>
   istream_iterator&lt;int&gt; iterIn(cin);
   int number1 = *iterIn; <span class="color-comment"> // dereference to get the value</span>
   ++iterIn;              <span class="color-comment"> // next int in cin</span>
   int number2 = *iterIn;
 
   *iterOutStr = "You have entered ";
   *iterOut = number1;
   *iterOutStr = " and ";
   *iterOut = number2;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5 class="">Example: <span class="font-code">copy()</span> to <span class="font-code">ostream_iterator</span></h5>

<p class="">The STL algorithm <code class="">copy()</code> can be used to copy elements from one container to another container. <code class="">copy()</code> is a template function defined as follows:</p>

<pre class="color-syntax">template &lt;class InputIterator, class OutputIterator&gt;
outputIterator <strong class="">copy</strong> (InputIterator first, InputIterator last, OutputIterator result);</pre>

<p class="">It copies the elements in the range of <code class="">[first,last)</code> to the output range beginning at <code class="">result</code>. As mentioned, <code class="">InputIterator</code> shall provide read access and <code class="">OutputIterator</code> write access. Input and output could be the same container, but result cannot be in <code class="">[first,last)</code>. For example,</p>

<pre class="color-example">const int SIZE = 10;
int array[SIZE] = {11, 55, 44, 33, 88, 99, 11, 22, 66, 77};
vector&lt;int&gt; v(array, array + SIZE);  <span class="color-comment">// Copy constructor</span>
 
<span class="color-comment">// Using copy() instead of copy constructor</span>
vector&lt;int&gt; v2(SIZE);
copy(array, array + SIZE, v2.begin());</pre>

<p class="">You could also copy to an output stream such as <code class="">cout</code>, i.e., print, by using the STL's pre-defined <code class="">ostream_iterator</code> (in header <code class="">&lt;iterator&gt;</code>), which is a class template defined as follows:</p>

<pre class="color-syntax">template &lt;class T, class charT = char, class traits = char_traits&lt;charT&gt; &gt;
class <strong class="">ostream_iterator</strong>;
   <span class="color-comment">// T is the data type, charT is the character type (such as char or wchar_t)</span>
 
<span class="color-comment">// Example</span>
ostream_iterator&lt;int, char&gt; out (cout, " ");
   <span class="color-comment">// data type (T) is int, character type (charT) is char.
   // output stream is cout, delimiter is a space (" ")</span></pre>
   
<p class="">In the following example, we used <code class="">copy()</code> to copy one container into output stream, via a <code class="">ostream_iterator</code>. This code replaces the <code class="">print()</code> user-defined function and seems to be more compact.</p>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></td>
<td class="">
<pre class=""><span class="color-comment">/*
 *  Testing ostream_iterator (TestOstreamIterator.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
using namespace std;
 
int main() {
   const int SIZE = 10;
   int array[SIZE] = {11, 55, 44, 33, 88, 99, 11, 22, 66, 77};
   vector&lt;int&gt; v(array, array + SIZE);
 
  <span class="color-comment"> // Construct an ostream_iterator called out</span>
   <span class="color-new">ostream_iterator&lt;int, char&gt; out (cout, " ");</span>
  <span class="color-comment"> // Copy to ostream, via ostream_iterator - replacing the print()</span>
   copy(v.begin(), v.end(), <span class="color-new">out</span>);
   cout &lt;&lt; endl;
 
  <span class="color-comment"> // Copy to ostream in reverse order</span>
   copy(v.<span class="color-new">rbegin()</span>, v.<span class="color-new">rend()</span>, out);
   cout &lt;&lt; endl;
 
  <span class="color-comment"> // Use an anonymous ostream_iterator</span>
   copy(v.begin(), v.end(), <span class="color-new">ostream_iterator&lt;int, char&gt;(cout, " ")</span>);
   cout &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h5 class="">Example: <span class="font-code">insert_iterator</span></h5>

<p class="">The <code class="">copy()</code> with a <code class="">OutputIterator</code> (as in the above example) override the existing data in the output range. Instead you could use one of the insert_iterator to insert elements without overriding existing data. A <code class="">front_insert_iterator</code> inserts from the front; a <code class="">back_insert_iterator</code> inserts at the end; an <code class="">insert_iterator</code> inserts before a given location.</p>

<pre class="color-example">vector&lt;int&gt; v(10);
back_insert_iterator&lt;vector&lt;int&gt; &gt; back_iter (v);
    <span class="color-comment">// Construct a back_insert_iterator for v
    // The template type argument is the container
    // The constructor argument is the name of container
    // Need to write "&gt; &gt;" instead of "&gt;&gt;"</span>
 
insert_iterator&lt;vector&lt;int&gt; &gt; insert_iter (v, v.begin());
    <span class="color-comment">// The constructor's 2nd argument specifies insert before this location</span></pre>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 *  Testing insert_iterator (TestInsertIterator.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
using namespace std;
 
int main() {
   int a1[5] = {11, 55, 44, 33, 88};
   vector&lt;int&gt; v(a1, a1+5);
   ostream_iterator&lt;int, char&gt; out (cout, " "); <span class="color-comment"> // for printing</span>
   copy(v.begin(), v.end(), out);
   cout &lt;&lt; endl;
 
  <span class="color-comment"> // Construct a back_insert_iterator to insert at the end</span>
   <span class="color-new">back_insert_iterator&lt;vector&lt;int&gt; &gt; back (v);</span>
   int a2[3] = {91, 92, 93};
   <span class="color-new">copy(a2, a2+3, back);</span>
   copy(v.begin(), v.end(), out);
   cout &lt;&lt; endl;
 
  <span class="color-comment"> // Use an anonymous insert_iterator to insert at the front</span>
   int a3[3] = {81, 82, 83};
   <span class="color-new">copy(a3, a3+3, insert_iterator&lt;vector&lt;int&gt; &gt;(v, v.begin()));</span>
   copy(v.begin(), v.end(), out);
   cout &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4 class="">2.5&nbsp;&nbsp;Algorithm<a id="zz-2.5" class="" style=""></a></h4>
<p class="">C++ provides a set of generic algorithm for STD in header <code class="">&lt;algorithm&gt;</code>, which includes:</p>
<ul class="">
<li class="">Searching: <code class="">find()</code>, <code class="">count()</code>.</li>
<li class="">Sorting: <code class="">sort()</code>, <code class="">partial_sort()</code>, <code class="">merge()</code>.</li>
<li class="">Generation, mutation and deletion:</li>
<li class="">Numeric and relational:</li>
</ul>

<p class="">The algorithms operate on elements of STL container only indirectly through the iterator.</p>
<p class="">The generic algorithms are non-member functions that are applicable to all STL containers. It accepts a pair of iterators, denoted as <code class="">first</code> and <code class="">last</code>, that mark the range of operation as <code class="">[first,last)</code> (including first, but excluding last). For example,</p>

<pre class="color-example">sort(aVector.begin(), aVector.end());  <span class="color-comment">// Sort the entire vector</span>
sort(aVector.begin(), aVector.begin + aVector.size()/2);  <span class="color-comment">// Sort first half</span></pre>

<p class="">Let's begin with some examples.</p>

<h5 class="">Example 1: <span class="font-code">sort()</span>, <span class="font-code">reverse()</span>, <span class="font-code">random_shuffle()</span> and <span class="font-code">find()</span> on Iterators <span class="font-code">[first,last)</span></h5>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 *  Testing algorithms (TestAlgorithm.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
 
void print(vector&lt;int&gt; &amp; v);
 
int main() {
   const int SIZE = 10;
   int array[SIZE] = {11, 55, 44, 33, 88, 99, 11, 22, 66, 77};
   vector&lt;int&gt; v(array, array + SIZE);
   print(v);
 
  <span class="color-comment"> // Sort</span>
   <span class="color-new">sort(v.begin(), v.end());</span>  <span class="color-comment">// entire container [begin(),end())</span>
   print(v);
 
  <span class="color-comment"> // Reverse</span>
   <span class="color-new">reverse(v.begin(), v.begin() + v.size()/2);</span>  <span class="color-comment">// First half</span>
   print(v);
 
  <span class="color-comment"> // Random Shuffle</span>
   <span class="color-new">random_shuffle(v.begin() + 1, v.end() - 1);</span>  <span class="color-comment">// exclude first and last elements</span>
   print(v);
 
  <span class="color-comment"> // Search</span>
   int searchFor = 55;
   vector&lt;int&gt;::iterator <span class="color-new">found = find(v.begin(), v.end(), searchFor)</span>;
   if (found != v.end()) {
      cout &lt;&lt; "Found" &lt;&lt; endl;
   }
   return 0;
}
 
<span class="color-comment">// Use iterator to print the entire vector</span>
void print(vector&lt;int&gt; &amp; v) {
   for (vector&lt;int&gt;::iterator iter = v.begin(); iter != v.end(); ++iter) {
      cout &lt;&lt; *iter &lt;&lt; " ";  <span class="color-comment"> // dereference</span>
   }
   cout &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>

<pre class="output">11 55 44 33 88 99 11 22 66 77
11 11 22 33 44 55 66 77 88 99
44 33 22 11 11 55 66 77 88 99
44 55 22 77 11 33 66 88 11 99
Found</pre>

<p class="">Program Notes:</p>

<ul class="">
<li class="">Most of the algorithm functions takes at least two iterators: <code class="">first</code> and <code class="">last</code>, to specify the range <code class="">[first,last)</code> of operation. They could have additional parameters.</li>
<li class="">All STL containers provides members functions <code class="">begin()</code> and <code class="">end()</code>, which return the begin and pass-the-end elements of the container, respectively.</li>
<li class="">To apply sort, the elements shall have overloaded the <code class="">'&lt;'</code> operator, which is used for comparing the order of the elements.</li>

</ul>

<h5 class="">Example 2: <span class="font-code">for_each()</span></h5>

<p class="">The <code class="">for_each()</code> applies a function to each element of the given range.</p>

<pre class="color-syntax">template &lt;class InputIterator, class Function&gt;
Function <strong class="">for-each</strong> (InputIterator first, InputIterator last, Function f);</pre>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 *  Testing for_each algorithms (TestForEach.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
 
void square(int &amp; n);
void print(int &amp; n);
 
int main() {
   vector&lt;int&gt; v;
   v.push_back(11);
   v.push_back(3);
   v.push_back(4);
   v.push_back(22);
 
  <span class="color-comment"> // Invoke the given function (print, square)</span>
  <span class="color-comment"> // for each element in the range</span>
   <span class="color-new">for_each</span>(v.begin(), v.end, <span class="color-new">print</span>);
   <span class="color-new">for_each</span>(v.begin() + 1, v.begin() + 3, <span class="color-new">square</span>);
   <span class="color-new">for_each</span>(v.begin(), v.end, <span class="color-new">print</span>);
   return 0;
}
 
void square(int &amp; n) { n *= n; }
 
void print(int &amp; n) { cout &lt;&lt; n &lt;&lt; " "; }</pre>
</td>
</tr>
</tbody>
</table>

<p class="">[TODO]</p>

<h5 class="">algorithm Functions</h5>

<p class="">[TODO]</p>

<h4 class="">2.6&nbsp;&nbsp;Function Object (Functors)<a id="zz-2.6" class="" style=""></a></h4>

<p class="">Most of the STL algorithms use so-called <em class="">function objects</em> or <em class="">functors</em>. A functor is an object that can be used with <code class="">()</code> operator, which includes regular functions, function pointers and class object with overloaded <code class="">()</code> operator.</p>

<h5 class=""><span class="font-code">for_each()</span> algorithm</h5>

<p class="">The <code class="">for_each()</code> algorithm, discussed earlier, takes a functor as its third argument, and apply the function to all the elements in the given range.</p>

<h5 class=""><span class="font-code">transform()</span> algorithm</h5>

<p class=""><code class="">transform()</code> algorithm has two versions, supporting unary and binary operations, respectively.</p>

<pre class="color-syntax"><span class="color-comment">// Unary Operation</span>
template &lt;class InputIterator, class OutputIterator, class UnaryOperation&gt;
OutputIterator <strong class="">transform</strong> (InputIterator first, InputIterator last,
                         OutputIterator result, UnaryOperation op)
   <span class="color-comment">// Perform unary operation on each element in [first,last) and
   // store the output in range beginning at result</span></pre>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 *  Testing transform() algorithms (TestTransform.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cmath&gt;
using namespace std;
 
int square(int n) { return n*n; }
 
int main() {
   vector&lt;int&gt; v;
   v.push_back(2);
   v.push_back(-3);
   v.push_back(4);
   v.push_back(3);
   ostream_iterator&lt;int, char&gt; out(cout, " ");
   copy(v.begin(), v.end(), out);
   cout &lt;&lt; endl;
 
   <span class="color-new">transform(v.begin(), v.end(), v.begin(), square);</span>
   copy(v.begin(), v.end(), out);
   cout &lt;&lt; endl;
 
   <span class="color-new">transform(v.begin(), v.end(), out, ::sqrt);</span> <span class="color-comment"> // in &lt;cmath&gt;</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 *  Testing transform() algorithms (TestTransform.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;
using namespace std;
 
string &amp; strtoupper(string &amp; str);
 
int main() {
   vector&lt;string&gt; v;
   v.push_back("apple");
   v.push_back("orange");
   v.push_back("banana");
   ostream_iterator&lt;string, char&gt; out(cout, " ");
   copy(v.begin(), v.end(), out);
   cout &lt;&lt; endl;
 
   transform(v.begin(), v.end(), v.begin(), strtoupper);
   copy(v.begin(), v.end(), out);
   cout &lt;&lt; endl;
   return 0;
}
 
<span class="color-comment">// Convert the given string to uppercase</span>
<span class="color-comment">// Use transform() on each character with toupper()</span>
string &amp; strtoupper(string &amp; str) {
   transform(str.begin(), str.end(), str.begin(), ::toupper); <span class="color-comment"> // toupper in &lt;cctype&gt;</span>
   return str;
}
 </pre>
</td>
</tr>
</tbody>
</table>


<pre class="color-syntax"><span class="color-comment">// Binary Operation</span>
template &lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation&gt;
OutputIterator <strong class="">transform</strong> (InputIterator1 first1, InputIterator1 last1,
                         InputIterator2 first2,
                         OutputIterator result, BinaryOperation op)
   <span class="color-comment">// Perform binary operation on each element in [first1,last1) as first argument,
   // and the respective [frist2,...) as second argument.
   // Store the output in range beginning at result</span></pre>

<p class="">The header <code class="">&lt;functional&gt;</code> contains many functors that can be used in <code class="">transform()</code> algorithm, e.g., arithmetic (<code class="">plus</code>, <code class="">minus</code>, <code class="">multiplies</code>, <code class="">divides</code>, <code class="">modulus</code>, <code class="">negate</code>), relational (<code class="">equal_to</code>, <code class="">not_equal_to</code>, <code class="">greater</code>, <code class="">less</code>, <code class="">greater_equal</code>, <code class="">less_equal</code>), and logical (<code class="">logical_and</code>, <code class="">logical_or</code>, <code class="">logical_not</code>), etc.</p>

<pre class="color-syntax">template &lt;class T&gt;
struct plus;

<span class="color-comment">// Example</span>
plus&lt;int&gt; add;
int result = add(1, 2);</pre>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 *  Testing transform() algorithms on binary operator (TestTransformBinary.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;functional&gt;
using namespace std;
 
int square(int n) { return n*n; }
 
int main() {
   int a1[5] = {1, 2, 3, 4, 5};
   int a2[5] = {11, 12, 13, 14, 15};
 
   vector&lt;int&gt; v1(a1, a1+5);
   vector&lt;int&gt; v2(a2, a2+5);
   ostream_iterator&lt;int, char&gt; out(cout, " ");
   copy(v1.begin(), v1.end(), out);
   cout &lt;&lt; endl;
   copy(v2.begin(), v2.end(), out);
   cout &lt;&lt; endl;
 
   transform(v1.begin(), v1.end(), v2.begin(), out, plus&lt;int&gt;());
      <span class="color-comment"> // Send result to output stream</span>
   cout &lt;&lt; endl;
 
   transform(v1.begin(), v1.end(), v2.begin(), v1.begin(), minus&lt;int&gt;());
      <span class="color-comment"> // Store result back to v1</span>
   copy(v1.begin(), v1.end(), out);
   cout &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<p class="">Suppose that you want to add all elements by 8. The functor <code class="">plus</code> is a binary operator. You can use functors <code class="">bind1st</code> or <code class="">bind2nd</code> to bind the value of the first or second argument. For example,</p>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 *  Testing functors bind1st and bind2nd (TestFunctorBind.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;functional&gt;
using namespace std;
 
int square(int n) { return n*n; }
 
int main() {
   int a1[5] = {1, 2, 3, 4, 5};
   int a2[5] = {11, 12, 13, 14, 15};
 
   vector&lt;int&gt; v1(a1, a1+5);
   vector&lt;int&gt; v2(a2, a2+5);
   ostream_iterator&lt;int, char&gt; out(cout, " ");
   copy(v1.begin(), v1.end(), out);
   cout &lt;&lt; endl;
   copy(v2.begin(), v2.end(), out);
   cout &lt;&lt; endl;
 
   transform(v1.begin(), v1.end(), out, bind2nd(minus&lt;int&gt;(), 8));
   cout &lt;&lt; endl;
 
   transform(v1.begin(), v1.end(), out, bind1st(minus&lt;int&gt;(), 8));
   cout &lt;&lt; endl;
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4 class="">2.7&nbsp;&nbsp;STL and the <span class="font-code">string</span> class<a id="zz-2.7" class="" style=""></a></h4>

<p class="">The <code class="">string</code> class is not part of the STL, but has implemented many STL features. <code class="">string</code> can be treated as a STL container of <code class="">char</code>. It defines member functions <code class="">begin()</code>, <code class="">end()</code>, <code class="">rbegin()</code>, <code class="">rend()</code> which returns an iterator for forward and reverse transversal. Most of the algorithms (such as <code class="">transform()</code>, <code class="">sort()</code>) are applicable to <code class="">string</code>, operating on individual characters.</p>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 *  Testing string on STL algorithms (TestStringSTL.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;cctype&gt;
using namespace std;
 
int main() {
   string s1("apples");
   cout &lt;&lt; s1 &lt;&lt; endl;  <span class="color-comment"> // "apples"</span>
   <span class="color-new">sort(s1.begin(), s1.end());</span>
   cout &lt;&lt; s1 &lt;&lt; endl;  <span class="color-comment"> // "aelpps"</span>
 
   <span class="color-new">transform(s1.begin(), s1.end(), s1.begin(), ::toupper);</span>
   cout &lt;&lt; s1 &lt;&lt; endl;  <span class="color-comment"> // "AELPPS"</span>
   <span class="color-new">transform(s1.begin(), s1.end(), s1.begin(), bind1st(plus&lt;char&gt;(), 'a'-'A'));</span>
   cout &lt;&lt; s1 &lt;&lt; endl;  <span class="color-comment"> // "aelpps"</span>
   return 0;
}</pre>
</td>
</tr>
</tbody>
</table>

<h4 class="">2.8&nbsp;&nbsp;<span class="font-code">vector</span>, <span class="font-code">valarray</span> and <span class="font-code">array</span><a id="zz-2.8" class="" style=""></a></h4>

<p class="">C++ has 3 array template classes: <code class="">vector</code>, <code class="">valarray</code>, <code class="">array</code> (C++11). <code class="">vector</code> and <code class="">array</code> are STL; while <code class="">valarray</code> is not.</p>

<h5 class=""><span class="font-code">vector</span></h5>

<p class=""><code class="">vector</code> is certainly the most commonly used STL container. <code class="">vector</code> is dynamically allocated, with support for <code class="">push_back()</code> and <code class="">insert()</code>.</p>

<h5 class=""><span class="font-code">array</span></h5>

<p class="">The <code class="">array</code> class is a wrapper for the fixed-sized built-in array with the STL container interfaces. It is designed as a substitute for the built-in array type, for applications where dynamic resizable <code class="">vector</code> is not needed (so as to reduce the overhead of dynamic array). <code class="">array</code> does not support <code class="">push_back()</code> and <code class="">insert()</code>, as it cannot be resized.</p>

<h5 class=""><span class="font-code">valarray</span></h5>

<p class=""><code class="">valarray</code> is designed for numeric computation. It is variable-size but does not supports STL operations such as <code class="">push_back()</code> or <code class="">insert</code>, but provides a simple interface for many mathematical operations. For example, the arithmetic operators (such as +, -, <code class="">*</code>, <code class="">/</code>, <code class="">%</code>) and mathematical functions (such as <code class="">pow</code>, <code class="">sqrt</code>, <code class="">exp</code>, <code class="">log</code>, <code class="">sin</code>, <code class="">cos</code>, etc.) are overloaded to operate on the entire valarray (instead of individual element). For example,</p>

<table class="table-program">
<colgroup class="" style=""><col class="col-line-number" style="">
<col class="col-program" style="">
</colgroup><tbody class="">
<tr class="">
<td class="">
<pre class="text-right">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre>
</td>
<td class="">
<pre class=""><span class="color-comment">/*
 *  Testing valarray (Testvalarray.cpp)
 */</span>
#include &lt;iostream&gt;
#include &lt;valarray&gt;
using namespace std;
 
void print(const valarray&lt;int&gt; &amp; va);
 
int main() {
   const int SIZE = 5;
   int a1[SIZE] = {1, 2, 3, 4, 2};
   int a2[SIZE] = {11, 12, 13, 14, 15};
   valarray&lt;int&gt; va1(a1, SIZE);
   valarray&lt;int&gt; va2(a2, SIZE);
   valarray&lt;int&gt; va3(SIZE);  <span class="color-comment">// all 0</span>
   print(va1);
   print(va2);
   print(va3);
 
   <span class="color-new">va3 = va1 + va2;</span>  <span class="color-comment"> // + operates on all elements</span>
   print(va3);
 
   <span class="color-new">va3 = pow(va2, va1);</span> <span class="color-comment"> // pow() operates on elements</span>
   print(va3);
 
   cout &lt;&lt; "sum is " &lt;&lt; <span class="color-new">va1.sum()</span> &lt;&lt; endl;
   cout &lt;&lt; "max is " &lt;&lt; <span class="color-new">va1.max()</span> &lt;&lt; endl;
   cout &lt;&lt; "min is " &lt;&lt; <span class="color-new">va1.min()</span> &lt;&lt; endl;
   return 0;
}
 
void print(const valarray&lt;int&gt; &amp; va) {
   for (int i = 0; i &lt; va.size(); ++i) {
      cout &lt;&lt; va[i] &lt;&lt; " ";
   }
   cout &lt;&lt; endl;
}</pre>
</td>
</tr>
</tbody>
</table>


<h4 class="">2.9&nbsp;&nbsp;STL Containers<a id="zz-2.9" class="" style=""></a></h4>

<p class="">C++98/03 has 11 containers: <code class="">vector</code>, <code class="">stack</code>, <code class="">list</code>, <code class="">queue</code>, <code class="">deque</code>, <code class="">priority_queue</code>, <code class="">map</code>, <code class="">multimap</code>, <code class="">set</code>, <code class="">multiset</code> and <code class="">bitset</code>. C++11 added <code class="">forward_list</code>, <code class="">unordered_map</code>, <code class="">unordered_multimap</code>, <code class="">unordered_set</code> and <code class="">unordered_multiset</code>, and moves <code class="">bitset</code> from container category to its own separate category. <code class="">string</code> is not really part of STL, but implemented many STL concepts.</p>

<p class="">The STL container are template class, which can be instantiated with a type. The actual type has to be <em class="">copy constructable</em> (having copy constructor) and <em class="">assignable</em> (overload <code class="">=</code> operator).</p>

<h5 class="">Sequence Container</h5>

<p class="">A sequence container requires that elements are arranged in a strict linear order.</p>

<ul class="">
<li class=""><code class="">vector</code>: direct-access class-representation of dynamic array. Elements can be added and removed from the end in constant time. But insertion and removal not from the end require linear time. It supports direct-access, as well as bidirectional transversal.</li>

<li class=""><code class="">deque</code>: (pronounced "deck") double-ended queue, allow elements to be added and removed from both the front and the rear, at constant time. The <code class="">deque</code> implementation in STL is similar to <code class="">vector</code>, which allows direct access. It is more complex than <code class="">vector</code>, as it allows constant-time insertion and removal from the front and rear; whereas vector only for rear.</li>

<li class=""><code class="">list</code>: double-linked list that can be transverse in both direction. It support constant-time insertion and removal, but does not allow direct (random) access with no indexing operator.</li>

<li class=""><code class="">forward_list</code> (C++11): single-linked list that support forward transversal only. It is simpler than <code class="">list</code>.</li>

<li class=""><code class="">queue</code>: allow elements to be added at the rear and removed from the front at constant time. STL's <code class="">queue</code> is very restrictive that it does not support direct access nor transversal through the elements.</li>

<li class=""><code class="">priority_queue</code>: Similar to <code class="">queue</code>, but move the larger element to the front of the queue.</li>

<li class=""><code class="">stack</code>: LIFO (last-in-first-out) queue, elements can be added and removed from the top-of-stack in a last-in-first-out manner. In STL, <code class="">stack</code> is an adapter class over the <code class="">vector</code> class. It is more restrictive than vector. Elements can only be accessed, added and removed from one-end (top-of-stack). It does not support direct access, nor transversal through all the elements.</li>
<li class=""><code class="">array</code> (C++11): <code class="">array</code> is NOT a STL container because it has a fixed size and does not support operations like insert. But you can apply STL algorithms on <code class="">array</code> container.</li>
</ul>

<h5 class="">Associative Containers</h5>

<p class="">Associative container stores key-value pair or name-value pairs (i.e., associate a key with a value, and use a key to find the value). Associative container (or associative array) is actually similar to an array or vector, where a numerical index key is associated with a value, and you use the numerical key to find a value. Example of key-value pair are person-phone number(s), id-name, etc.</p>

<p class="">STL supports the following associative containers:</p>

<ul class="">
<li class=""><code class="">set</code>: the key is the same as the value. It does not allow duplicate values. STL <code class="">set</code> is sorted and reversible.</li>

<li class=""><code class="">multiset</code>: allow duplicate values.</li>

<li class=""><code class="">map</code>: key-value pair, where keys are unique. One key is associated with one value. STL <code class="">map</code> is sorted and reversible. It needs two types to instantiate: <code class="">map&lt;<em class="">key-type</em>, <em class="">value-type</em>)</code>. To represent each key-value, STL provides a template class called <code class="">pair&lt;class K, class V&gt;</code>. You can instantiate the template class with specific key-type and value-type, e.g., <code class="">pair&lt;const int, string&gt;</code>.</li>

<li class=""><code class="">multimap</code>: one key could be associated with multiple values.</li>
<li class="">C++11 added 4 unordered associative containers: <code class="">unordered_set</code>, <code class="">unordered_multiset</code>, <code class="">unordered_map</code>, and <code class="">unordered_multimap</code>. These unordered associative containers are based on hash table (efficient in insertion, removal and search, but requires more storage spaces); whereas the ordered counterparts are based on tree.</li>

</ul>

<h5 class="">Example: <span class="font-code">map</span></h5>

<p class="">[TODO]</p>

<a class="references" href="http://www.ntu.edu.sg/home/ehchua/programming/howto/References.html#cpp">Link to "C++ References &amp; Resources"</a>


</div> <!-- End the content-main division -->

<div id="content-footer" class="">
<p class="">Latest version tested: GCC 4.6.2<br class="">
Last modified: May, 2013</p>
</div>

</div>  <!-- End the wrap-inner division -->

<!-- footer filled by JavaScript -->
<div id="footer" class="header-footer"><p class="">Feedback, comments, corrections, and errata can be sent to Chua Hock-Chuan (ehchua@ntu.edu.sg) &nbsp;&nbsp;|&nbsp;&nbsp; <a href="http://www.ntu.edu.sg/home/ehchua/programming/index.html" class="">HOME</a></p></div>

</div>  <!-- End the wrap-outer division -->


<div class="selection_bubble_root" style=""></div><div id="gritter-notice-wrapper" class="bottom-left"><div id="gritter-item-1" class="gritter-item-wrapper "><div class="gritter-top"></div><div class="gritter-item"><div class="gritter-close"></div><div class="gritter-without-image"><span class="gritter-title">Text Zoom</span><p>Level 100%</p></div><div style="clear:both"></div></div><div class="gritter-bottom"></div></div></div></body></html>